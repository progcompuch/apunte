<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Grafos on</title><link>/apunte/grafos/</link><description>Recent content in Grafos on</description><generator>Hugo -- gohugo.io</generator><atom:link href="/apunte/grafos/index.xml" rel="self" type="application/rss+xml"/><item><title>Introducción</title><link>/apunte/grafos/introduccion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/grafos/introduccion/</guid><description>¿Qué son los grafos? # Los grafos son un tipo específico de estructura que nos sirve para modelar muchos problemas distintos. Estos se representan como un conjunto de puntos $V$ (llamados vértices o nodos) conectados por un conjunto de líneas $E$ (llamadas aristas o arcos). Las aristas pueden ser no-dirigidas (se pueden recorrer en ambas direcciones) o dirigidas y pueden tener peso o no.
El área de grafos ha sido muy estudiada y se han desarrollado múltiples algoritmos para trabajar con ellos.</description></item><item><title>Búsqueda en grafos (BFS y DFS)</title><link>/apunte/grafos/busqueda_en_grafos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/grafos/busqueda_en_grafos/</guid><description>Búsqueda en grafos # Ahora, sabemos que podemos modelar problemas con grafos y cómo guardarlos de forma eficiente pero no podemos hacer nada aún con ellos. Estos primeros algoritmos que veremos ahora son esenciales y se usan con demasiada frecuencia así que es importante entenderlos bien.
Para estos dos algoritmos (y en general) usaremos listas de adyacencia, dado que de esta manera es mucho más eficiente listar los vecinos de un nodo.</description></item><item><title>Caminos y ciclos eulerianos</title><link>/apunte/grafos/caminos_ciclos_eulerianos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/grafos/caminos_ciclos_eulerianos/</guid><description>Introducción # Un camino euleriano es un camino que ocupa todas las aristas de un grafo sin repetirlas. Además, este camino será un ciclo euleriano si también es un ciclo (empieza y termina en el mismo nodo). Primero asumiremos un grafo no dirigido y al final hablaremos de grafos dirigidos. Permitiremos que sea un multigrafo (con aristas repetidas entre un par de nodos).
A continuación un camino euleriano. Nota que los nodos de inicio y fin están marcados, y las aristas están enumeradas:</description></item><item><title>Minimum spanning tree</title><link>/apunte/grafos/minimum_spanning_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/grafos/minimum_spanning_tree/</guid><description>El Minimum Spanning Tree (MST) o Árbol Recubridor Mínimo es un subconjunto de las aristas de un grafo que conectan a todos los vértices usando el menor peso posible.
En este ejemplo podemos ver el grafo completo con las aristas grises y el subgrafo MST marcado en negro que deja a todos los vértices conectados usando la menor suma de los pesos de las aristas posible.
Esto es un árbol siempre que todas las aristas sean positivas 1 ya que si no fuera un árbol, existe un ciclo y si existe un ciclo, podemos eliminar la arista más pesada del ciclo y el grafo sigue conectado con menor peso.</description></item><item><title>Caminos más cortos</title><link>/apunte/grafos/caminos_mas_cortos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/grafos/caminos_mas_cortos/</guid><description>Camino más corto en un grafo # Con frecuencia encontraremos problemas en los que necesitamos encontrar el camino más corto para llegar desde un nodo hasta otro y dependiendo de las características del grafo tendremos que usar algoritmos distintos. Nota que en un grafo pueden haber múltiples caminos más cortos (con el mismo peso).
Grafos sin peso # Si las aristas del grafo no tienen peso, entonces su distancia es solo la cantidad de aristas por las que se pasa, luego podemos calcular la distancia desde un nodo cualquiera $u$ a todos los demás usando un solo BFS ya que este recorre el grafo expandiéndose.</description></item></channel></rss>