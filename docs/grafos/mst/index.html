<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.c9e56e89b640498932b48f88666fb7dafea2240ca0093d87b8cb2c324b7aa2613f76be82154ceadb06ad2f89c479e382f13e99e177b0ed1817eb59625b34f389.css integrity="sha512-yeVuibZASYkytI+IZm+32v6iJAygCT2HuMssMkt6omE/dr6CFUzq2watL4nEeeOC8T6Z4Xew7RgX61liWzTziQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Minimum Spanning Tree (MST) - Programación Competitiva UChile</title><meta name=description content="DCC universidad de Chile"><link rel=canonical href=/docs/grafos/mst/><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo_redondo.png"><meta name=twitter:title content="Minimum Spanning Tree (MST)"><meta name=twitter:description content="MST El Minimum Spanning Tree o Árbol Recubridor Mínimo es un subconjunto de las aristas de un grafo que conectan a todos los vértices usando el menor peso posible.
  En este ejemplo podemos ver el grafo completo con las aristas grises y el subgrafo MST marcado en negro que deja a todos los vértices conectados usando la menor suma de los pesos de las aristas posible.
Esto es un árbol siempre que todas las aristas sean positivas 1 ya que si no fuera un árbol, existe un ciclo y si existe un ciclo, podemos eliminar la arista más pesada del ciclo y el grafo sigue conectado con menor peso."><meta name=twitter:site content="@dccuchile"><meta name=twitter:creator content="@dccuchile"><meta property="og:title" content="Minimum Spanning Tree (MST)"><meta property="og:description" content="MST El Minimum Spanning Tree o Árbol Recubridor Mínimo es un subconjunto de las aristas de un grafo que conectan a todos los vértices usando el menor peso posible.
  En este ejemplo podemos ver el grafo completo con las aristas grises y el subgrafo MST marcado en negro que deja a todos los vértices conectados usando la menor suma de los pesos de las aristas posible.
Esto es un árbol siempre que todas las aristas sean positivas 1 ya que si no fuera un árbol, existe un ciclo y si existe un ciclo, podemos eliminar la arista más pesada del ciclo y el grafo sigue conectado con menor peso."><meta property="og:type" content="article"><meta property="og:url" content="/docs/grafos/mst/"><meta property="og:image" content="/logo_redondo.png"><meta property="article:published_time" content="2022-03-19T08:48:45+00:00"><meta property="article:modified_time" content="2022-04-09T17:13:10-04:00"><meta property="og:site_name" content="Programación Competitiva UChile"><meta property="article:publisher" content="https://www.facebook.com/DCCUChile"><meta property="article:author" content="https://www.facebook.com/DCCUChile"><meta property="og:locale" content="es_CL"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"\/"},{"@type":"ListItem","position":2,"name":"Docsgrafosmst","item":"\/docsgrafosmst\/"}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body class="docs single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 mr-auto" href=/><img class=logo-light src=/images/banner.svg></img>
<img class=logo-dark src=/images/banner_dark.svg></img></a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/progcompuch/apunte><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ml-2 sr-only">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav mr-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=/docs/prologo/intro>Apunte</a></li><li class=nav-item><a class=nav-link href=/recursos/prologo/intro>Recursos</a></li><li class=nav-item><a class=nav-link href=/cses>CSES</a></li><li class=nav-item><a class=nav-link href=/acerca>Acerca</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Buscar Documentación..." aria-label="Buscar Documentación..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><div class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Prólogo</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/prologo/intro/>Prólogo</a></li></ul><h3>Intro a la Programación</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/intro/compilacion-editores/>Compilación y Editores de Texto</a></li><li><a class=docs-link href=/docs/intro/sintaxis/>Sintaxis, Variables, Tipos y Ciclos</a></li><li><a class=docs-link href=/docs/intro/funciones/>Funciones en C++</a></li><li><a class=docs-link href=/docs/intro/vectores/>Vectores</a></li><li><a class=docs-link href=/docs/intro/bits/>Operadores Bitwise</a></li></ul><h3>La STL</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/stl/strings/>Chars y Strings</a></li><li><a class=docs-link href=/docs/stl/setmap/>Sets, Maps y Multisets</a></li><li><a class=docs-link href=/docs/stl/stackqueue/>Stack y Queue</a></li><li><a class=docs-link href=/docs/stl/priority_queue/>Priority Queue</a></li><li><a class=docs-link href=/docs/stl/pair-tuple/>Pair y Tuple</a></li></ul><h3>Paradigmas de Resolución</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/paradigmas/busqueda-binaria/>Búsqueda Binaria</a></li><li><a class=docs-link href=/docs/paradigmas/programacion-dinamica/>Programación Dinámica</a></li></ul><h3>Estructuras de Datos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/ds/unionfind/>Union Find</a></li></ul><h3>Grafos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/grafos/introduccion/>Introducción</a></li><li><a class=docs-link href=/docs/grafos/busqueda/>Búsqueda en grafos (BFS y DFS)</a></li><li><a class="docs-link active" href=/docs/grafos/mst/>Minimum Spanning Tree (MST)</a></li><li><a class=docs-link href=/docs/grafos/dijkstra/>Camino más corto en un grafo</a></li></ul><h3>Anexos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/anexos/template/>Template</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>Contenidos</h3><nav id=TableOfContents><ul><li><ul><li><a href=#mst>MST</a></li><li><a href=#algoritmo-de-kruskal>Algoritmo de Kruskal</a></li><li><a href=#algoritmo-de-prim>Algoritmo de Prim</a></li><li><a href=#minimax-y-maximin>Minimax (y Maximin)</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>Minimum Spanning Tree (MST)</h1><p class=lead></p><h3 id=mst>MST<a href=#mst class=anchor aria-hidden=true>#</a></h3><p>El Minimum Spanning Tree o Árbol Recubridor Mínimo es un subconjunto de las aristas de un grafo que conectan a todos los vértices usando el menor peso posible.</p><center><img class=invertible src=../mst.png width=450></center><p>En este ejemplo podemos ver el grafo completo con las aristas grises y el subgrafo MST marcado en negro que deja a todos los vértices conectados usando la menor suma de los pesos de las aristas posible.</p><p>Esto es un árbol siempre que todas las aristas sean positivas <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> ya que si no fuera un árbol, existe un ciclo y si existe un ciclo, podemos eliminar la arista más pesada del ciclo y el grafo sigue conectado con menor peso.</p><p>Los algoritmos que vamos a enseñar para encontrar los algoritmos son bastante simples y pueden parecer poco formales, pero funcionan y existen pruebas de que funcionan si les interesa buscar.</p><h3 id=algoritmo-de-kruskal>Algoritmo de Kruskal<a href=#algoritmo-de-kruskal class=anchor aria-hidden=true>#</a></h3><p>El algoritmo de Kruskal ordena las aristas de menor a mayor peso y para cada arista revisa si está conectando dos componentes desconectadas usando un <a href=https://uchile.progcomp.cl/docs/ds/unionfind/>Union Find</a> para determinar si dos nodos son parte del mismo conjunto.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>typedef</span> <span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>ii</span><span class=p>;</span>
<span class=k>typedef</span> <span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=n>ii</span><span class=o>&gt;</span> <span class=n>iii</span><span class=p>;</span>
<span class=c1>// Toma una lista de adyacencia con pares (vecino,peso)
</span><span class=c1>// Retorna una lista de adyacencia con las aristas del MST
</span><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>kruskal</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>gr</span><span class=p>){</span>
	<span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>gr</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
	<span class=n>vector</span><span class=o>&lt;</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>ans</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
	<span class=c1>// Creamos una lista de aristas y agregamos todas las aristas del grafo
</span><span class=c1></span>	<span class=n>vector</span><span class=o>&lt;</span><span class=n>iii</span><span class=o>&gt;</span> <span class=n>edges</span><span class=p>;</span>
	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
		<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>gr</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span><span class=p>();</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
			<span class=n>edges</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>gr</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>].</span><span class=n>second</span><span class=p>,</span><span class=n>i</span><span class=p>,</span><span class=n>gr</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>].</span><span class=n>first</span><span class=p>);</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=c1>// Ordenamos las aristas por peso de menor a mayor
</span><span class=c1></span>	<span class=n>sort</span><span class=p>(</span><span class=n>edges</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span><span class=n>edges</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
	<span class=c1>// Creamos nuestro Union Find
</span><span class=c1></span>	<span class=n>ufset</span> <span class=nf>uf</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>edges</span><span class=p>.</span><span class=n>size</span><span class=p>();</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
		<span class=kt>int</span> <span class=n>repa</span> <span class=o>=</span> <span class=n>uf</span><span class=p>.</span><span class=n>findp</span><span class=p>(</span><span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>second</span><span class=p>.</span><span class=n>first</span><span class=p>);</span>
		<span class=kt>int</span> <span class=n>repb</span> <span class=o>=</span> <span class=n>uf</span><span class=p>.</span><span class=n>findp</span><span class=p>(</span><span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>second</span><span class=p>.</span><span class=n>second</span><span class=p>);</span>
		<span class=c1>// Si la arista conecta dos nodos que están en conjuntos distintos
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>repa</span> <span class=o>!=</span> <span class=n>repb</span><span class=p>){</span>
			<span class=c1>// Agregamos la arista a la respuesta
</span><span class=c1></span>			<span class=n>ans</span><span class=p>[</span><span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>second</span><span class=p>.</span><span class=n>first</span><span class=p>].</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>second</span><span class=p>.</span><span class=n>second</span><span class=p>,</span><span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>first</span><span class=p>);</span>
			<span class=n>ans</span><span class=p>[</span><span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>second</span><span class=p>.</span><span class=n>second</span><span class=p>].</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>second</span><span class=p>.</span><span class=n>first</span><span class=p>,</span><span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>first</span><span class=p>);</span>
			<span class=c1>// Y unimos los dos conjuntos
</span><span class=c1></span>			<span class=n>uf</span><span class=p>.</span><span class=n>uni</span><span class=p>(</span><span class=n>repa</span><span class=p>,</span><span class=n>repb</span><span class=p>);</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h3 id=algoritmo-de-prim>Algoritmo de Prim<a href=#algoritmo-de-prim class=anchor aria-hidden=true>#</a></h3><p>El algoritmo de Prim toma un vértice cualquiera para empezar y marca a todos los demás como no visitados. Agrega todas las aristas del vértice a una <a href=https://uchile.progcomp.cl/docs/stl/priority_queue/>Priority Queue</a> y sacamos la arista más pequeña que visite a un nodo nuevo, agregamos esta arista a nuestra respuesta, marcamos el nodo nuevo y agregamos las aristas que nos trae este nodo a la cola.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>typedef</span> <span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>ii</span><span class=p>;</span>
<span class=k>typedef</span> <span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=n>ii</span><span class=o>&gt;</span> <span class=n>iii</span><span class=p>;</span>
<span class=c1>// Toma una lista de adyacencia con pares (vecino,peso)
</span><span class=c1>// Retorna una lista de adyacencia con las aristas del MST
</span><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>prim</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>gr</span><span class=p>){</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>gr</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
    <span class=n>vector</span><span class=o>&lt;</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>ans</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>visitado</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=nb>false</span><span class=p>);</span>
    <span class=n>priority_queue</span><span class=o>&lt;</span> <span class=n>iii</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>iii</span><span class=o>&gt;</span><span class=p>,</span><span class=n>greater</span><span class=o>&lt;</span><span class=n>iii</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>pq</span><span class=p>;</span>
    <span class=c1>// Marcamos el nodo 0 como visitado y agregamos sus aristas
</span><span class=c1></span>    <span class=n>visitado</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>ii</span> <span class=nl>ve</span><span class=p>:</span><span class=n>gr</span><span class=p>[</span><span class=mi>0</span><span class=p>]){</span>
        <span class=n>pq</span><span class=p>.</span><span class=n>emplace</span><span class=p>(</span><span class=n>ve</span><span class=p>.</span><span class=n>second</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>ve</span><span class=p>.</span><span class=n>first</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=c1>// Recorremos la pq tomando las aristas más pequeñas primero
</span><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>pq</span><span class=p>.</span><span class=n>empty</span><span class=p>()){</span>
        <span class=n>iii</span> <span class=n>enlace</span> <span class=o>=</span> <span class=n>pq</span><span class=p>.</span><span class=n>top</span><span class=p>();</span>
        <span class=n>pq</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
        <span class=kt>int</span> <span class=n>peso</span> <span class=o>=</span> <span class=n>enlace</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>nodo</span> <span class=o>=</span> <span class=n>enlace</span><span class=p>.</span><span class=n>second</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>vecino</span> <span class=o>=</span> <span class=n>enlace</span><span class=p>.</span><span class=n>second</span><span class=p>.</span><span class=n>second</span><span class=p>;</span>
        <span class=c1>// Si el vecino de esta arista no ha sido visitado...
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>visitado</span><span class=p>[</span><span class=n>vecino</span><span class=p>]){</span>
            <span class=c1>// Agregamos la arista a la respuesta
</span><span class=c1></span>            <span class=n>ans</span><span class=p>[</span><span class=n>nodo</span><span class=p>].</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>vecino</span><span class=p>,</span><span class=n>peso</span><span class=p>);</span>
            <span class=n>ans</span><span class=p>[</span><span class=n>vecino</span><span class=p>].</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>nodo</span><span class=p>,</span><span class=n>peso</span><span class=p>);</span>
            <span class=c1>// Lo marcamos como visitado
</span><span class=c1></span>            <span class=n>visitado</span><span class=p>[</span><span class=n>vecino</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
            <span class=c1>// Agregamos todas sus aristas a la pq
</span><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=n>ii</span> <span class=nl>ve</span><span class=p>:</span><span class=n>gr</span><span class=p>[</span><span class=n>vecino</span><span class=p>]){</span>
                <span class=n>pq</span><span class=p>.</span><span class=n>emplace</span><span class=p>(</span><span class=n>ve</span><span class=p>.</span><span class=n>second</span><span class=p>,</span><span class=n>vecino</span><span class=p>,</span><span class=n>ve</span><span class=p>.</span><span class=n>first</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// Retornamos el grafo construido
</span><span class=c1></span>    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Este algoritmo no es popular debido a lo enredado que es de implementar en comparación con Kruskal.</p><h3 id=minimax-y-maximin>Minimax (y Maximin)<a href=#minimax-y-maximin class=anchor aria-hidden=true>#</a></h3><p>El problema del camino Minimax es encontrar el camino de un vértice a otro en el grafo tal que se minimice el peso de la arista más pesada del camino. El Maximin se define al revés, el camino que maximice el peso de la arista más liviana.</p><p>Un problema clásico de este tipo es que tenemos computadoras conectadas con cables con una capacidad $c$, entonces la velocidad máxima va a estar en el camino donde la arista más pequeña sea lo más grande posible, o sea, Maximin.</p><p>Los caminos para esta pregunta son los caminos del MST (en el caso del Maximin se usa el Maximum Spanning Tree que es fácil de construir ordenando las aristas al revés) entonces para calcular estas respuestas solo es necesario revisar la máxima arista del camino.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Dado que tenemos el MST en gr
</span><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span> <span class=o>&gt;</span><span class=n>gr</span><span class=p>;</span>
<span class=c1>// Calculamos cuál es la máxima arista del nodo s a los demás
</span><span class=c1></span><span class=kt>int</span> <span class=n>s</span><span class=p>;</span>
<span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>cost</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
<span class=n>cost</span><span class=p>[</span><span class=n>s</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=c1>// Usamos un BFS para recorrer el grafo
</span><span class=c1></span><span class=n>queue</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>bfs</span><span class=p>;</span>
<span class=n>bfs</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
<span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>bfs</span><span class=p>.</span><span class=n>empty</span><span class=p>()){</span>
	<span class=kt>int</span> <span class=n>no</span> <span class=o>=</span> <span class=n>bfs</span><span class=p>.</span><span class=n>front</span><span class=p>();</span>
	<span class=n>bfs</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
	<span class=k>for</span> <span class=p>(</span><span class=n>ii</span> <span class=nl>ne</span><span class=p>:</span><span class=n>gr</span><span class=p>[</span><span class=n>no</span><span class=p>]){</span>
		<span class=c1>// Si no lo hemos visitado
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>cost</span><span class=p>[</span><span class=n>ne</span><span class=p>.</span><span class=n>first</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>){</span>
			<span class=c1>// Su costo va a ser el máximo entre el costo del nodo y esta nueva arista
</span><span class=c1></span>			<span class=n>cost</span><span class=p>[</span><span class=n>ne</span><span class=p>.</span><span class=n>first</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>ne</span><span class=p>.</span><span class=n>second</span><span class=p>,</span><span class=n>cost</span><span class=p>[</span><span class=n>no</span><span class=p>]);</span>
			<span class=n>bfs</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>ne</span><span class=p>);</span>
		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Si las aristas pueden ser negativas, se puede hacer todo el procedimiento para encontrar el MST normalmente y luego agregar todas las aristas negativas que sobraron. Deja de ser un árbol claramente pero tiene menor peso conectando todos los vértices. Mientras entiendas el procedimiento no tendrás problemas para resolver un problema que necesita usar MST. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section><p class=edit-page><a href=https://github.com/progcompuch/apunte/blob/main/content/docs/grafos/mst.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Editar en GitHub</a>
<span class=date-info><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Modificado por última vez el 09/04/2022 a las 17:13:10 hrs.</span></p><div class="docs-navigation d-flex justify-content-between"><a href=/docs/grafos/busqueda/><div class="card my-1"><div class="card-body py-2">&larr; Búsqueda en grafos (BFS y DFS)</div></div></a><a class=ml-auto href=/docs/grafos/dijkstra/><div class="card my-1"><div class="card-body py-2">Camino más corto en un grafo &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Sitio generado con <a href=https://gohugo.io/>Hugo</a> y <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-right"><ul class=list-inline><a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></ul></div></div></div></footer><script src=/main.95e1e463215c36b92eed561d2047bd705784633ba53d9459f103fad71ac9237a03e92e1413824339f4dcfe6e260239c0e4237a48be33d73a1e686e025142d2ba.js integrity="sha512-leHkYyFcNrku7VYdIEe9cFeEYzulPZRZ8QP61xrJI3oD6S4UE4JDOfTc/m4mAjnA5CN6SL4z1zoeaG4CUULSug==" crossorigin=anonymous defer></script><script src=/index.min.adbe41a659bf3f4b7fcaafbc04acccae435527cfc25c53bc2e317d25c42087f2c8d0ed02f0af04d182de9d7851e4ad37dab6d2c6e20fb20b04da6b70db6f5a65.js integrity="sha512-rb5Bplm/P0t/yq+8BKzMrkNVJ8/CXFO8LjF9JcQgh/LI0O0C8K8E0YLenXhR5K032rbSxuIPsgsE2mtw229aZQ==" crossorigin=anonymous defer></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>