<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.0ce842cb63b215ba8d61d4f188cdc42d3560f46238210188ce494f7fea26b58e7a43f81f53e114beec80e352f582637fa440d4da21c0508c971824a36b077806.css integrity="sha512-DOhCy2OyFbqNYdTxiM3ELTVg9GI4IQGIzklPf+omtY56Q/gfU+EUvuyA41L1gmN/pEDU2iHAUIyXGCSjawd4Bg==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Treaps - Programaci칩n Competitiva UChile</title><meta name=description content="DCC universidad de Chile"><link rel=canonical href=/docs/extras/treaps/><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo_redondo.png"><meta name=twitter:title content="Treaps"><meta name=twitter:description content="Introducci칩n 쯈ue cosa es un treap? El nombre viene de la mezcla de dos cosas, tree (치rboles binarios de busqueda) + heap, y es por que esta estructura incorpora caracter칤sticas de ambas. Antes de entrar en detalle en los treaps, hagamos un peque침o repaso sobre 치rboles binarios de busqueda.
츼rboles binarios de busqueda Un 치rbol binario de busqueda, es, como lo dice su nombre, un 치rbol binario donde cada nodo del 치rbol cumple las siguientes dos propiedades:"><meta name=twitter:site content="@dccuchile"><meta name=twitter:creator content="@dccuchile"><meta property="og:title" content="Treaps"><meta property="og:description" content="Introducci칩n 쯈ue cosa es un treap? El nombre viene de la mezcla de dos cosas, tree (치rboles binarios de busqueda) + heap, y es por que esta estructura incorpora caracter칤sticas de ambas. Antes de entrar en detalle en los treaps, hagamos un peque침o repaso sobre 치rboles binarios de busqueda.
츼rboles binarios de busqueda Un 치rbol binario de busqueda, es, como lo dice su nombre, un 치rbol binario donde cada nodo del 치rbol cumple las siguientes dos propiedades:"><meta property="og:type" content="article"><meta property="og:url" content="/docs/extras/treaps/"><meta property="og:image" content="/logo_redondo.png"><meta property="article:published_time" content="2022-12-04T02:48:45+00:00"><meta property="article:modified_time" content="2022-12-09T00:56:41-03:00"><meta property="og:site_name" content="Programaci칩n Competitiva UChile"><meta property="article:publisher" content="https://www.facebook.com/DCCUChile"><meta property="article:author" content="https://www.facebook.com/DCCUChile"><meta property="og:locale" content="es_CL"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"\/"},{"@type":"ListItem","position":2,"name":"Docsextrastreaps","item":"\/docsextrastreaps\/"}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body class="docs single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 mr-auto" href=/><img class=logo-light src=/images/banner.svg></img>
<img class=logo-dark src=/images/banner_dark.svg></img></a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/progcompuch/apunte><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ml-2 sr-only">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav mr-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=/docs/prologo/intro>Apunte</a></li><li class=nav-item><a class=nav-link href=/recursos/prologo/intro>Recursos</a></li><li class=nav-item><a class=nav-link href=/cses>CSES</a></li><li class=nav-item><a class=nav-link href=/acerca>Acerca</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Buscar Documentaci칩n..." aria-label="Buscar Documentaci칩n..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><main class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Pr칩logo</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/prologo/intro/>Pr칩logo</a></li></ul><h3>Intro a la Programaci칩n</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/intro/compilacion-editores/>Compilaci칩n y Editores de Texto</a></li><li><a class=docs-link href=/docs/intro/sintaxis/>Sintaxis, Variables, Tipos y Ciclos</a></li><li><a class=docs-link href=/docs/intro/funciones/>Funciones en C++</a></li><li><a class=docs-link href=/docs/intro/vectores/>Vectores</a></li><li><a class=docs-link href=/docs/intro/bits/>Operadores Bitwise</a></li></ul><h3>La STL</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/stl/strings/>Chars y Strings</a></li><li><a class=docs-link href=/docs/stl/pair-tuple/>Pair y Tuple</a></li><li><a class=docs-link href=/docs/stl/sort/>Sort</a></li><li><a class=docs-link href=/docs/stl/setmap/>Sets, Maps y Multisets</a></li><li><a class=docs-link href=/docs/stl/stackqueue/>Stack y Queue</a></li><li><a class=docs-link href=/docs/stl/priority_queue/>Priority Queue</a></li></ul><h3>Paradigmas de Resoluci칩n</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/paradigmas/busqueda-binaria/>B칰squeda Binaria</a></li><li><a class=docs-link href=/docs/paradigmas/programacion-dinamica/>Programaci칩n Din치mica</a></li></ul><h3>Estructuras de Datos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/ds/unionfind/>Union Find</a></li></ul><h3>Grafos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/grafos/introduccion/>Introducci칩n</a></li><li><a class=docs-link href=/docs/grafos/busqueda/>B칰squeda en grafos (BFS y DFS)</a></li><li><a class=docs-link href=/docs/grafos/caminos_eulerianos/>Caminos y Ciclos Eulerianos</a></li><li><a class=docs-link href=/docs/grafos/mst/>Minimum Spanning Tree (MST)</a></li><li><a class=docs-link href=/docs/grafos/dijkstra/>Caminos m치s cortos</a></li></ul><h3>Extras</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/extras/recurrencias_lineales/>Recurrencias Lineales</a></li><li><a class="docs-link active" href=/docs/extras/treaps/>Treaps</a></li></ul><h3>Anexos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/anexos/template/>Template</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>Contenidos</h3><nav id=TableOfContents><ul><li><a href=#치rboles-binarios-de-busqueda>츼rboles binarios de busqueda</a><ul><li><a href=#teorema>Teorema:</a></li></ul></li></ul><ul><li><a href=#base>Base</a><ul><li><a href=#teorema-1>Teorema</a></li><li><a href=#merge>Merge</a></li><li><a href=#split>Split</a></li><li><a href=#busqueda>Busqueda</a></li><li><a href=#inserci칩n>Inserci칩n</a></li><li><a href=#eliminaci칩n>Eliminaci칩n</a></li><li><a href=#implementaci칩n>Implementaci칩n</a></li><li><a href=#llaves-repetidas>Llaves repetidas</a></li></ul></li><li><a href=#extensiones>Extensiones</a><ul><li><a href=#cuantiles>Cuantiles</a></li><li><a href=#rango>Rango</a></li></ul></li><li><a href=#-treaps-como-mapas--arreglos-> Treaps como mapas / arreglos ?</a></li><li><a href=#implicit-treap>Implicit Treap</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>Treaps</h1><p class=lead></p><h1 id=introducci칩n>Introducci칩n</h1><p>쯈ue cosa es un <em>treap</em>? El nombre viene de la mezcla de dos cosas, <em>tree</em> (치rboles binarios de busqueda) + <em>heap</em>, y es por que esta estructura incorpora caracter칤sticas de ambas. Antes de entrar en detalle en los treaps, hagamos un peque침o repaso sobre 치rboles binarios de busqueda.</p><h2 id=치rboles-binarios-de-busqueda>츼rboles binarios de busqueda<a href=#치rboles-binarios-de-busqueda class=anchor aria-hidden=true>#</a></h2><p>Un 치rbol binario de busqueda, es, como lo dice su nombre, un 치rbol binario donde cada nodo del 치rbol cumple las siguientes dos propiedades:</p><ul><li>Cada nodo del 치rbol tiene un valor que llamaremos <strong>llave</strong></li><li>Para cada nodo, todas las llaves guardadas en su sub치rbol izquierdo tienen valor $&lt;$ al de su propia llave, y todas las llaves guardadas en el sub치rbol derecho tienen valor $>$</li></ul><p>Un ejemplo de un 치rbol binario de busqueda:</p><center><img class=invertible src=../ABB1.png width=450></center><p>Del ejemplo debemos destacar un par de cosas:</p><ol><li>No estamos pidiendo que el 치rbol sea <strong>completo</strong>, es decir, que cada nodo tenga dos hijos o ninguno. Est치 bien si un nodo tiene un solo hijo.</li><li>A pesar de que en el ejemplo se usen n칰meros enteros como llaves, esto es solo para ilustrar y las llaves no necesariamente deben ser n칰meros enteros. Solo necesitaremos que las llaves sean valores que tengan alguna idea de &ldquo;ord칠n&rdquo;. Por ejemplo, podr칠mos usar llaves que sean strings, pares de n칰meros, etc. En el resto de este documento asumiremos que las llaves si son n칰meros enteros, pero insistimos en que no necesariamente lo tienen que ser siempre.</li><li>En este modelo <strong>no permitimos</strong> que hayan valores repetidos en el 치rbol.</li></ol><p>Algunos de ustedes quiz치s recuerden los 치rboles binarios de busqueda de alg칰n ramo de programaci칩n. Quiz치s recuerden que la gracia de estos era que es f치cil hacer un programa que decide si un valor se encuentra en el 치rbol o no:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>struct</span> <span class=nc>tree</span> <span class=p>{</span>
  <span class=n>tree</span> <span class=o>*</span><span class=n>left</span><span class=p>,</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span> <span class=c1>// Los hijos izquierdo y derecho
</span><span class=c1></span>  <span class=kt>int</span> <span class=n>key</span><span class=p>;</span> <span class=c1>// El valor llave
</span><span class=c1></span>
  <span class=n>tree</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>key</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
    <span class=n>left</span> <span class=o>=</span> <span class=n>right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>};</span>

<span class=c1>// Decide si x se encuentra en el 치rbol
</span><span class=c1></span><span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>tree</span> <span class=o>*</span><span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Un 치rbol vac칤o no tienen nada
</span><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// Encontramos x
</span><span class=c1></span>
  <span class=c1>// Si es menor que la llave, debe estar en el sub치rbol izquierdo
</span><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

  <span class=c1>// Y si no, en el derecho
</span><span class=c1></span>  <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Tambi칠n es bastante simple crear un programa que inserta valores en el 치rbol, encontrando la posici칩n hoja correcta donde va:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// Inserta x en el 치rbol y devuelve el 치rbol actualizado
</span><span class=c1></span><span class=n>tree</span><span class=o>*</span> <span class=nf>insert</span><span class=p>(</span><span class=n>tree</span> <span class=o>*</span><span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Si el 치rbol era vac칤o, devolvemos el 치rbol con solo x
</span><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=k>new</span> <span class=n>tree</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> 

  <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=k>return</span> <span class=n>T</span><span class=p>;</span> <span class=c1>// x ya se encontraba en el 치rbol
</span><span class=c1></span>
  <span class=c1>// Si x es menor que la llave del 치rbol, 
</span><span class=c1></span>  <span class=c1>// lo insertamos a la izquierda.
</span><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span> 

  <span class=c1>// Y si no, a la derecha
</span><span class=c1></span>  <span class=k>else</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

  <span class=c1>// Devolvemos el 치rbol actualizado
</span><span class=c1></span>  <span class=k>return</span> <span class=n>T</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>쮺ual es la complejidad de estos algoritmos? Bueno, en el peor caso de ambas funciones debemos bajar por todo el 치rbol hasta una hoja, por lo que en el peor caso esto toma la altura del 치rbol pasos. Si llamamos $H(T)$ a la altura del 치rbol (del ingl칠s <em>height</em>), podemos escribir que estos algoritmos toman tiempo $O(H(T))$.</p><p>&mldr; 쯆k, y que tan grande puede ser $H(T)$? Bueno, si insertamos $N$ valores, todos en ord칠n, resulta que el 치rbol resultante tiene $H(T) = N$. Por ejemplo, si insertamos los valores del $1$ al $5$ en orden, el 치rbol resultante se ve as칤:</p><center><img class=invertible src=../ABB2.png width=250></center><p>Es decir que, en el peor caso esta estructura no es mejor que buscar e insertar en un arreglo 游땟. Existen m칠todos para mantener $H(T)$ bajo, por ejemplo, los 치rboles <strong>AVL</strong> agregan una invariante adicional que asegura que el 치rbol mantiene una profundidad $H(T) = O(\log N)$. Pero, Refleja esto el caso promedio del 치rbol? Resulta que no, en el caso que ingresamos $n$ valores en un orden aleatorio, la 치ltura del 치rbol resultante tendr치 un valor de $O(\log n)$ en esperanza. Hablaremos de este tipo de 치rboles como un <strong>치rbol binario aleatorio</strong>, cuando ingresamos los valores en un orden aleatorio en un 치rbol binario de busqueda.</p><p>Vamos a dar primero una demostraci칩n de un resultado m치s debil:</p><h3 id=teorema>Teorema:<a href=#teorema class=anchor aria-hidden=true>#</a></h3><p>La profundidad esperada de cualquier nodo en un 치rbol binario aleatorio es $O(\log n)$.</p><h4 id=demostraci칩n>Demostraci칩n<a href=#demostraci칩n class=anchor aria-hidden=true>#</a></h4><p>Como vamos a ingresar $n$ valores al 치rbol y solo nos importa su orden, podemos pensar que estamos ingresando los valores $\{1, 2, \dots n\}$. Tambi칠n, por simplicidad, vamos a referirnos indistintamente a el valor $x$ y al nodo que contiene a $x$ de la misma forma. Vamos a necesitar un lema:</p><h4 id=lema>Lema:<a href=#lema class=anchor aria-hidden=true>#</a></h4><p>Para un par de valores $1 \leq x &lt; y \leq n$, $x$ ser치 ancestro de $y$ si y solamente si $x$ es el primer valor en llegar del rango $[x, y]$. El caso que $x > y$ es an치logo pidiendo que $x$ sea el primero en llegar del rango $[y, x]$.</p><p>Demostraremos solamente el caso $x &lt; y$, por que el otro de nuevo es an치logo. Cuando $x$ llega primero, cualquier valor de $[x+1, y]$ va a querer insertarse en el sub치rbol derecho de $x$ y ser치 descendiente de $x$. Si llegar치 $z$ tal que $x &lt; z &lt; y$ primero, $x$ se insertar치 en el sub치rbol izquierdo e $y$ en el sub치rbol derecho, por lo que $x$ no podr치 ser ancestro de $y$. Y, finalmente, en el caso que $y$ llegar치 primero claramente $x$ no podr치 ser ancestro de $y$ si es que llega despu칠s.</p><p>$\blacksquare$</p><p>Con esto, podemos decir que la probabilidad de que $x$ sea ancestro de $y$ es exactamente $\frac{1}{(1+|x-y|)}$, que es el tama침o del rango $[x, y]$. Denotando $P(y)$ por la profundidad de $y$, vemos que esto es equivalente a la cantidad de ancestros que tenga $y$ y luego expresamos:</p><p>$$
\begin{align*}
P(y) &= \sum_{x=1}^{y-1} \mathbf{1}_{y \text{ es ancestro de } x} + \sum_{x=y+1}^{n} \mathbf{1}_{y \text{ es ancestro de } x} \\<br>\Rightarrow \mathbb{E}(P(y)) &= \sum_{x=1}^{y-1} \mathbb{E}(\mathbf{1}_{y \text{ es ancestro de } x}) + \sum_{x=y+1}^{n} \mathbb{E}(\mathbf{1}_{y \text{ es ancestro de } x}) \\<br>\Rightarrow \mathbb{E}(P(y)) &= \sum_{x=1}^{y-1} \mathbb{P}(y \text{ es ancestro de } x) + \sum_{x=y+1}^{n} \mathbb{P}(y \text{ es ancestro de } x) \\<br>\Rightarrow \mathbb{E}(P(y)) &= \sum_{x=1}^{y-1} \frac{1}{1+(y-x)} + \sum_{x=y+1}^{n} \frac{1}{1+(x-y)} \\[1.5em]
\Rightarrow \mathbb{E}(P(y)) &\leq H_{y-1} + H_{n-y+1} \leq 2H_n = O(\log n)
\end{align*}
$$</p><p>Donde $H_n$ corresponde al $n$-esimo n칰mero 치rmonico. Conclu칤mos que la profundidad esperada es $O(\log n)$.</p><p>$\square$</p><p>Este resultado nos dice que en promedio, las operaciones en 치rboles binarios aleatorios nos tomar치n tiempo en $O(\log n)$, pero no nos da seguridad respecto al peor caso. Podemos obtener un resultado a칰n m치s fuerte de que la altura de un 치rbol binario aleatorio es efectivamente $O(\log n)$, dejaremos la demostraci칩n aparte para los interesados.</p><details><summary>Demostraci칩n profundidad</summary><p>Vamos a nombrar $X_n$ la variable aleatoria resultante de tomar un 치rbol binario aleatorio y luego obtener su altura. Si fijamos la identidad de la ra칤z del 치rbol en $[1, n]$, el sub치rbol izquierdo ser치 un 치rbol de $r-1$ valores y el derecho uno de $n-r$ valores. Esto nos permite escribir la esperanza condicional como:</p><p>$$
\mathbb{E}(X_n \mid r) = \max(1+X_{r-1}, 1+X_{n-r}) = 1 + \max(X_{r-1}, X_{n-r})
$$</p><p>Notar que la ra칤z de un 치rbol binario aleatorio es exactamente el valor que llega primero, as칤 que la ra칤z ser치 el valor $i \in [1, n]$ con probabilidad $\frac{1}{n}$. Con esto podemos expresar</p><p>$$
\mathbb{E}(X_n) = \sum_{i=1}^{n} \mathbb{E}(X_n \mid r = i)\mathbb{P}(r = i)
= 1 + \frac{1}{n} \sum_{i=1}^{n} \mathbb{E}(\max(X_{i-1}, X_{i-r}))
$$</p><p>Lamentablemente, esta expresi칩n no es amena a ser trabajada para demostrar que la altura sea $O(\log n)$ (por lo menos, no de una forma que yo conozca). Vamos a usar un truco y definiremos $Y_n = 2^{X_n}$, la altura <em>exponencial</em> del 치rbol. Podemos repetir el an치lisis anterior y expresar:</p><p>$$
\mathbb{E}(Y_n \mid r) = 2^{1+\max(X_{r-1}, X_{n-r})} = 2\max(2^{X_{r-1}}, 2^{X_{n-r}}) = 2\max(Y_{r-1}, Y_{n-r})
$$</p><p>Podemos acotar esta 칰ltima expresi칩n como $\mathbb{E}(Y_n \mid r) = 2\max(Y_{r-1}, Y_{n-r}) \leq 2(Y_{r-1} + Y_{n-r})$. Y luego, acotar el valor esperado de $Y_n$ como:</p><p>$$
\mathbb{E}(Y_n) = \sum_{i=1}^{n} \mathbb{E}(Y_n \mid r = i)\mathbb{P}(r = i)
\leq \frac{2}{n} \sum_{i=1}^{n} \mathbb{E}(Y_{i-1} + Y_{n-i}) = \frac{4}{n} \sum_{i=0}^{n-1} \mathbb{E}(Y_i)
$$</p><p>쯈ue pasa si repetimos est치 cota para el valor $\mathbb{E}(Y_{n-1})$ ? Vemos que:</p><p>$$
\newcommand{\E}{\mathbb{E}}
\begin{align*}
\mathbb{E}(Y_n) &\leq \frac{4}{n}\sum_{i=0}^{n-1} \mathbb{E}(Y_i)
= \frac{4}{n} \left[ \E(Y_{n-1}) + \sum_{i=0}^{n-2} \mathbb{E}(Y_i) \right] \\<br>&\leq \frac{4}{n} \left[ \frac{4}{n-1} \sum_{i=0}^{n-2}\E(Y_i) + \sum_{i=0}^{n-2} \mathbb{E}(Y_i) \right]
= \frac{4}{n} \frac{n+3}{n-1} \sum_{i=0}^{n-2} \mathbb{E}(Y_i)
\end{align*}
$$</p><p>Y si repetimos este procedimiento $n$ veces, podemos observar que:</p><p>$$
\mathbb{E}(Y_n) \leq 4\frac{(n+3)!}{3! n!} \mathbb{E}(Y_0) = 4 \binom{n+3}{3} = O(n^3)
$$</p><p>Tomando la convenci칩n de que $X_0 = 0$ para que $Y_0 = 1$. Con esta cota para el crecimiento de $\mathbb{E}(Y_n)$, podremos finalmente obtener una cota para el crecimiento de $\mathbb{E}(X_n)$. Utilizamos la <a href=https://en.wikipedia.org/wiki/Jensen%27s_inequality>desigualdad de Jensen</a> para afirmar que $2^{\mathbb{E}(X_n)} \leq \mathbb{E}(2^{X_n}) = \mathbb{E}(Y_n)$, y luego:</p><p>$$
2^{\mathbb{E}(X_n)} = O(n^3) \Rightarrow \mathbb{E}(X_n) = O(\log_2 n^3) = O(\log n)
$$</p><p>Y de hecho, obtenemos este resultado con una constante bastante competitiva de $3$. Se puede demostrar adicionalmente que la varianza de $X_n$ cumple que $\textbf{Var}(X_n) = O((\log \log n)^2)$ (<a href=https://epubs.siam.org/doi/pdf/10.1137/S0097539792237541>referencia</a>), pero no lo demostraremos aqu칤.</p></details><p>Armados con el resultado anterior, vemos que en el caso de que ingresemos valores a un 치rbol binario de busqueda en orden aleatorio, este tendr치 una altura razonable con probabilidad muy alta 游꿀.</p><p>&mldr; Ok, 쯫 de que nos sirve esto? En la gran mayor칤a de los casos, sobretodo en programaci칩n competitiva, no podremos asegurar que los valores vayan a ser ingresados de forma aleatoria a la estructura. Aqu칤 es donde va a entrar en juego la parte <em>heap</em> de la ecuaci칩n.</p><h1 id=treaps>Treaps</h1><h2 id=base>Base<a href=#base class=anchor aria-hidden=true>#</a></h2><p>Un peque침o repaso sobre <strong>heaps</strong>. Un <strong>heap</strong> es un 치rbol binario que cumple las siguientes dos condiciones:</p><ul><li>Cada nodo del 치rbol tiene un valor que llamaremos <strong>prioridad</strong></li><li>Para cada nodo, todas las prioridades guardadas en su sub치rbol izquierdo y derecho tienen valor $&lt;$ al de su propia prioridad.</li></ul><p>Esta definici칩n tambi칠n se puede usar usando la desigualdad al otro lado, pero la estructura definida es totalmente an치loga. Un ejemplo de un heap:</p><center><img class=invertible src=../Heap1.png width=450></center><p>Generalmente, se pide tambi칠n que un heap se치 un 치rbol binario completo, pero nosotros no lo requeriremos. Con esto, definiremos un <strong>treap</strong> como un 치rbol que tiene ambas las propiedades de un 치rbol binario de busqueda y un heap:</p><ul><li>Cada nodo del 치rbol tiene dos valores, una <strong>llave</strong> y una <strong>prioridad</strong></li><li>Para cada nodo, todas las llaves guardadas en su sub치rbol izquierdo tienen valor $&lt;$ al de su propia llave, y todas las llaves guardadas en el sub치rbol derecho tienen valor $>$</li><li>Para cada nodo, todas las prioridades guardadas en su sub치rbol izquierdo y derecho tienen valor $&lt;$ al de su propia prioridad.</li></ul><p>Aqu칤 un ejemplo de un treap, donde escribimos las prioridades en color rojo y las llaves en color azul:</p><center><img class=invertible src=../Treap1.png width=450></center><p>Los treaps cumplen una propiedad interesante de la que haremos uso:</p><h3 id=teorema-1>Teorema<a href=#teorema-1 class=anchor aria-hidden=true>#</a></h3><p>Si las prioridades en un treap <strong>no se repiten</strong>, entonces el treap tiene una sola posible estructura. M치s a칰n, la estructura es equivalente a la que hubiera resultado si hubieramos ingresado los nodos en orden descendiente de prioridad.</p><h4 id=demostraci칩n-1>Demostraci칩n<a href=#demostraci칩n-1 class=anchor aria-hidden=true>#</a></h4><p>Llamemos $p_{\min}$ al valor m칤nimo entre todas las prioridades del 치rbol, dado que todas las prioridades son distintas existe un 칰nico nodo que tenga prioridad $p_{\min}$. Dado la propiedad **heap**, la ra칤z del treap solamente puede ser este nodo. Aplicando inductivamente el mismo resultado sobre el sub치rbol izquierdo y el sub치rbol derecho obtenemos que la estructura es 칰nica.</p><p>$\square$</p><p>쮻e que sirve esta propiedad? Bueno, si asignamos las prioridades de forma aleatoria, 춰el treap resultante cumplira las mismas propiedades que ya demostramos para 치rboles binarios aleatorios 游꿀! Con esto podemos asegurar que al asignar las prioridades de forma aleatoria, independiente del orden en que ingresemos los valores al treap, este tendr치 con alta probabilidad una altura logar칤tmica respecto a la cantidad $n$ de valores que hayamos ingresado.</p><p>Bueno, 쯏 como obtenemos n칰meros aleatorios? En un computador, usando algoritmos, no podemos 游땝 (y a칰n sin usar algoritmos, no podemos obtenerlos de forma r치pida mediante ruido del ambiente u otra fuente aleatoria). Lo que podemos usar es alguna secuencia pseudo-aleatoria con suficiente entrop칤a (i.e. suficientemente &ldquo;aleatoria&rdquo;) para las prioridades.</p><p>En <strong>C++</strong>, existe una implementaci칩n del algoritmo <a href=https://en.wikipedia.org/wiki/Mersenne_Twister>Mersenne Twister</a> (춰el mismo usado por pok칠mon!) en la librer칤a est치ndar. (쯏 por qu칠 no usamos rand()? <a href=https://codeforces.com/blog/entry/61587>Por que es p칠simo</a>, poco aleatorio y por si fuera poco lento). En este snippet de c칩digo vemos como usar Mersenne Twister en C++:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// Numeros de 64 bits
</span><span class=c1></span><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>

<span class=c1>// Objeto que guarda el estado de la secuencia Mersenne Twister
</span><span class=c1></span><span class=n>mt19937_64</span> <span class=n>MT</span><span class=p>;</span>

<span class=c1>// Inicializa nuestro Mersenne Twister con la hora actual, que es 
</span><span class=c1>// suficientemente aleatoria. Llamar al principio del main
</span><span class=c1></span><span class=kt>void</span> <span class=nf>iniciar_MT</span><span class=p>()</span> <span class=p>{</span>
  <span class=n>MT</span> <span class=o>=</span> <span class=n>mt19937_64</span><span class=p>(</span><span class=n>chrono</span><span class=o>::</span><span class=n>system_clock</span><span class=o>::</span><span class=n>now</span><span class=p>().</span>
    <span class=n>time_since_epoch</span><span class=p>().</span><span class=n>count</span><span class=p>());</span>
<span class=p>}</span>

<span class=n>ll</span> <span class=nf>random_number</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>return</span> <span class=n>MT</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><p>Esto nos entregar numeros pseudo-aleatorios de $64$ bits. Un detalle importante es que nosotros necesit치bamos valores que no se repitieran para nuestro treap, y esto no nos asegura que no se vayan a repetir. La verdad es que no podemos asegurar que los valores no se vayan a repetir, pero si se repiten &ldquo;poco&rdquo; no tendremos problemas. Y dado que el espacio tiene tama침o $2^{64}$, aplicando la <a href=https://en.wikipedia.org/wiki/Birthday_problem>paradoja del cumplea침os</a> esperar칤amos ver la primera colisi칩n al insertar alrededor de $\sqrt{2^{64}} = 2^{32}$ valores. Cabe decir que en contextos de programaci칩n competitiva, podemos asumir que no habr치n repeticiones 游땔.</p><p>En lo que sigue, vamos a explicar como hacer las operaciones fundamentales en treaps a alto nivel. Al final de est치 secci칩n, incluiremos una implementaci칩n en C++. Necesitaremos antes dos algoritmos fundamentales:</p><h3 id=merge>Merge<a href=#merge class=anchor aria-hidden=true>#</a></h3><p><strong>Merge($T_1, T_2$)</strong> recibe dos treaps $T_1$ y $T_2$ que cumplen la condici칩n de que todas las llaves de $T_1$ son $&lt;$ a las llaves de $T_2$, y los junta en un solo treap $T$ que contiene todos sus nodos. Ojo que esto <strong>destruye</strong> $T_1$ y $T_2$ en el proceso. Dibujamos los treaps de la siguiente forma, donde $r_i$ es la ra칤z, $L_i$ es el sub치rbol izquierdo y $R_i$ es el sub치rbol derecho de cada 치rbol, respectivamente.</p><center><img class=invertible src=../TreapsMerge1.png width=600></center><p>Sabemos que la ra칤z del nuevo 치rbol deber치 ser el nodo entre $r_1, r_2$ que tenga mayor prioridad. Supongamos que es el caso que $r_1$ tiene mayor prioridad que $r_2$, entonces la ra칤z del nuevo 치rbol ser치 $r_1$:</p><center><img class=invertible src=../TreapsMerge2.png width=600></center><p>Donde separamos en el dibujo los valores que son menores a la llave de $r_1$ a la izquierda y a los valores mayores a la llave de $r_1$ a la derecha, usando el abuso de notaci칩n de referirnos a la llave de $r_1$ como $r_1$. Notemos que los valores menores a $r_1$ ya conforman un treap por que corresponden al sub치rbol $L_1$, entonces podemos mantenerlo como el sub치rbol izquierdo de $r_1$ sin problemas. Para el sub치rbol derecho, tenemos el problema de que tenemos dos treaps separados y si queremos usarlos como sub치rbol derecho debemos juntarnos en uno solo.</p><p>Justamente, podemos llamar recursivamente a <strong>Merge</strong> con <strong>Merge($R_1, T_2$)</strong> para obtener el sub치rbol derecho que necesitamos, y con esto asignar los sub치rboles apropiados:</p><center><img class=invertible src=../TreapsMerge3.png width=600></center><p>Con lo que logramos fusionar los 치rboles. Esto requiere que tengamos casos base para la recursi칩n, donde los casos base obvios son que un treap fusionado con un treap vac칤o resulta en el mismo treap. 쮺ual es la complejidad de este algoritmo? Bueno, con cada llamada recursiva estamos llamando el algoritmo de nuevo en un par de 치rboles donde al menos uno tiene una altura $1$ menor que la de su antecesor, por que la complejidad en el peor caso es $O(H(T_1) + H(T_2)) = O(\log n)$ si en total $T_1$ y $T_2$ tienen $n$ valores.</p><h3 id=split>Split<a href=#split class=anchor aria-hidden=true>#</a></h3><p><strong>Split</strong> recibe un treap $T$ y un valor $x$ y lo separa en dos treaps $T_1$ y $T_2$, tal que $T_1$ contiene todos los nodos con llaves $\leq x$ y $T_2$ aquellos nodos con llaves $>x$. Ojo que esto <strong>destruye</strong> el treap $T$ original. 쮺omo hacemos el split? Pong치monos en el caso que el valor de la ra칤z de $T$ es $\leq x$, entonces sabemos que tanto el sub치rbol izquierdo de $T$ y su ra칤z ser치n parte de $T_1$. Visualicemos esto, usando azul para marcar aquellos valores que ya sabemos que van en $T_1$, y rojo para aquellos valores que a칰n no sabemos donde van:</p><center><img class=invertible src=../TreapsSplit1.png width=600></center><p>Para separar los valores de $R$ que a칰n no sabemos donde van, vamos a llamar recursivamente a <strong>Split</strong> con <strong>Split($R, x$)</strong> para separar los valores de $R$ en $R_1, R_2$ donde $R_1$ contiene los valores que son $\leq x$ y $R_2$ los que son $>x$, y con esto construiremos $T_1$ y $T_2$ como corresponde:</p><center><img class=invertible src=../TreapsSplit2.png width=600></center><p>Como caso base consideraremos que el split de un treap vac칤o es, naturalmente, dos treaps vac칤os. Con esto, como llamamos recursivamente <strong>Split</strong> sobre un 치rbol que en el peor caso tiene altura a lo m치s $1$ menor que $T$, vemos que la complejidad de este algoritmo es $O(H(T)) = O(\log n)$.</p><p>A partir de estas operaciones, podremos construir las operaciones b치sicas que esperamos de un 치rbol de busqueda: buscar, insertar y eliminar valores. En los algoritmos que siguen, llamaremos a $T$ el treap a trabajar y $L, R$ a sus sub치rboles izquierdo y derecho respectivamente.</p><h3 id=busqueda>Busqueda<a href=#busqueda class=anchor aria-hidden=true>#</a></h3><p>Dado que un treap es tambi칠n un 치rbol binario de busqueda, podemos aplicar el mismo algoritmo de busqueda que usamos antes para este caso. La complejidad es la profundidad de $T$, que es $O(\log n)$</p><h3 id=inserci칩n>Inserci칩n<a href=#inserci칩n class=anchor aria-hidden=true>#</a></h3><p>Para insertar un valor $x$ en el treap, destacar que debemos verificar si $x$ se encuentra ya en el treap para evitar tener valores duplicados. Si $x$ no se encuentra en el treap $T$, podemos empaquetar el valor $x$ en un nodo $n$ con su prioridad aleatoria correspondiente y utilizar el siguiente algoritmo recursivo <strong>Insert($T, n$)</strong> para ingresarlo a $T$:</p><h4 id=insertt-n>Insert($T, n$)<a href=#insertt-n class=anchor aria-hidden=true>#</a></h4><ul><li>Si $T$ es el treap vac칤o, entonces la inserci칩n es lo mismo que asignar $T = n$.</li><li>Si la prioridad de $n$ es mayor a la prioridad de la ra칤z de $T$, $n$ se convertir치 en la ra칤z del treap. Llamamos a <strong>Split($T, x$)</strong> para separar $T$ en $T_1, T_2$ y asignamos $T_1$ como el sub치rbol izquierdo de $n$, $T_2$ como el derecho.</li><li>Si no es el caso y la prioridad es menor, llamamos <strong>Insert</strong> en el sub치rbol que corresponda para $x$, es decir, <strong>Insert($L, n$)</strong> si es que $x$ es $&lt;$ que la llave de $T$, e <strong>Insert($R, n$)</strong> en el caso contrario.</li></ul><p>En el peor caso, este algoritmo baja por todo el treap para ingresar $x$ y hace solamente una llamada a <strong>Split</strong>, por lo que tiene complejidad $O(\log n)$.</p><h3 id=eliminaci칩n>Eliminaci칩n<a href=#eliminaci칩n class=anchor aria-hidden=true>#</a></h3><p>Para eliminar un valor $x$ del treap, podemos utilizar un algoritmo recursivo similar al de inserci칩n. Lo llamaremos <strong>Erase($T, x$)</strong> y funciona de la siguiente forma:</p><h4 id=eraset-x>Erase($T, x$)<a href=#eraset-x class=anchor aria-hidden=true>#</a></h4><ul><li>Si $T$ es un treap vac칤o, podemos terminar pues $T$ no contiene a $x$.</li><li>Si la ra칤z de $T$ tiene llave con valor $x$, debemos eliminarla del treap. La removemos, y para juntar sus hijos en un solo treap llamamos a <strong>Merge($L, R$)</strong>.</li><li>Si no, bajamos al sub치rbol donde podr칤amos encontrar $x$ e intentamos de nuevo. Es decir, <strong>Erase($L, x$)</strong> si $x$ es $&lt;$ que la llave de $T$, <strong>Erase($R, x$)</strong> si no.</li></ul><p>Este algoritmo potencialmente puede bajar por todo el treap y hace una sola llamada a <strong>Merge</strong>, por lo que tendr치 complejidad $O(\log n)$.</p><h3 id=implementaci칩n>Implementaci칩n<a href=#implementaci칩n class=anchor aria-hidden=true>#</a></h3><p>Dejamos una implementaci칩n de todas las operaciones vistas hasta ahora, que ser치n el treap &ldquo;base&rdquo;.</p><details><summary>C칩digo</summary><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>

<span class=c1>// Clase wrapper
</span><span class=c1></span><span class=k>class</span> <span class=nc>treap</span> <span class=p>{</span>
<span class=k>private</span><span class=o>:</span>
  <span class=k>static</span> <span class=n>mt19937_64</span> <span class=n>MT</span><span class=p>;</span>

  <span class=k>static</span> <span class=n>ll</span> <span class=nf>random_number</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>MT</span><span class=p>();</span>
  <span class=p>}</span>

  <span class=k>struct</span> <span class=nc>node</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>left</span><span class=p>,</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>key</span><span class=p>,</span> <span class=n>priority</span><span class=p>;</span>

    <span class=n>node</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>left</span> <span class=o>=</span> <span class=n>right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=n>key</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
      <span class=n>priority</span> <span class=o>=</span> <span class=n>random_number</span><span class=p>();</span>
    <span class=p>}</span>    
  <span class=p>};</span>

  <span class=n>node</span> <span class=o>*</span><span class=n>root</span><span class=p>;</span>

  <span class=c1>// Guardamos en T el resultado
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si un 치rbol es vac칤o, retornamos el otro
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T2</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>

    <span class=c1>// Si T1 tiene mayor prioridad, su ra칤z ser치
</span><span class=c1></span>    <span class=c1>// la ra칤z del 치rbol fusionado
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// En el otro caso, gana la ra칤z de T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Guardaremos en T1, T2 los resultados
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>split</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// El split del treap vac칤o son dos treaps vac칤os
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T2</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si la llave de T es &lt;= x, entonces la ra칤z
</span><span class=c1></span>    <span class=c1>// y todo el sub치rbol izquierdo van en T1
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>&lt;=</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, la ra칤z y el sub치rbol derecho van en T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T2</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Un treap vac칤o no tiene nada
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// Encontramos x
</span><span class=c1></span>
    <span class=c1>// Si es menor que la llave, debe estar en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

    <span class=c1>// Y si no, en el derecho
</span><span class=c1></span>    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Llamada recursiva para ingresar nodo n
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si T es vac칤o, la inserci칩n es el nodo n
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si n tiene mayor prioridad que T, debe
</span><span class=c1></span>    <span class=c1>// ser la nueva ra칤z 
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, insertamos en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=c1>// si es que tiene una llave menor a la de T
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
    <span class=c1>// ... y en el caso contrario, en el sub치rbol derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>

    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// El treap vac칤o no contiene a x
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// Si la llave de T es x, debemos eliminar la ra칤z
</span><span class=c1></span>    <span class=c1>// y juntar sus sub치rboles
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, buscamos x en el sub치rbol izquierdo cuando
</span><span class=c1></span>    <span class=c1>// es menor que la llave de T
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>erase</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
    <span class=c1>// Y si no, intentamos en el sub치rbol derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>erase</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>

<span class=k>public</span><span class=o>:</span>
  <span class=n>treap</span><span class=p>()</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=p>}</span>
  <span class=n>treap</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=p>}</span>

  <span class=c1>// Fusiona O con T
</span><span class=c1></span>  <span class=n>treap</span> <span class=o>&amp;</span><span class=n>merge</span><span class=p>(</span><span class=n>treap</span> <span class=o>&amp;</span><span class=n>O</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>O</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Deja los valores &lt;= x en T, 
</span><span class=c1></span>  <span class=c1>// devuelve los valores &gt; x en otro treap
</span><span class=c1></span>  <span class=n>treap</span> <span class=nf>split</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>treap</span> <span class=n>ans</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>ans</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Busca x en el treap
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Inserta el valor x en el treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si x ya se encuentra en el 치rbol, no ingresarlo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>search</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// Si no, procedemos a ingresarlo
</span><span class=c1></span>    <span class=k>return</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=c1>// Elimina x del treap 
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>erase</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>};</span>

<span class=n>mt19937_64</span> <span class=n>treap</span><span class=o>::</span><span class=n>MT</span><span class=p>(</span><span class=n>chrono</span><span class=o>::</span><span class=n>system_clock</span><span class=o>::</span><span class=n>now</span><span class=p>().</span>
                    <span class=n>time_since_epoch</span><span class=p>().</span><span class=n>count</span><span class=p>());</span>
</code></pre></div></details><h3 id=llaves-repetidas>Llaves repetidas<a href=#llaves-repetidas class=anchor aria-hidden=true>#</a></h3><p>Bueno, hasta ahora hemos pedido que las llaves no se repitan, 쯈ue podemos hacer si queremos tener llaves repetidas en el treap? No podemos hacer algo simple como pedir que las llaves en el sub치rbol izquierdo sean $\leq$ a la llave de la ra칤z para incluir el caso en que son $=$, por que entonces si ingresamos $n$ veces la misma llave obtendr칤amos algo as칤:</p><center><img class=invertible src=../UnbalancedTreap.png width=450></center><p>Una soluci칩n m치s pr치ctica es agregar un contador a cada nodo de forma de representar cuantas veces se repite su llave, y al momento de ingresar o borrar valores del treap, si es que ya est치n presentes en el 치rbol incrementar o decrementar el contador seg칰n corresponda. Si el contador llega a $0$, borrar el valor. Por completitud, dejamos el c칩digo aqu칤:</p><details><summary>C칩digo</summary><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>

<span class=c1>// Clase wrapper
</span><span class=c1></span><span class=k>class</span> <span class=nc>treap</span> <span class=p>{</span>
<span class=k>private</span><span class=o>:</span>
  <span class=k>static</span> <span class=n>mt19937_64</span> <span class=n>MT</span><span class=p>;</span>

  <span class=k>static</span> <span class=n>ll</span> <span class=nf>random_number</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>MT</span><span class=p>();</span>
  <span class=p>}</span>

  <span class=k>struct</span> <span class=nc>node</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>left</span><span class=p>,</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>key</span><span class=p>,</span> <span class=n>priority</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>

    <span class=n>node</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>left</span> <span class=o>=</span> <span class=n>right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=n>key</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
      <span class=n>priority</span> <span class=o>=</span> <span class=n>random_number</span><span class=p>();</span>
      <span class=n>count</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>    
  <span class=p>};</span>

  <span class=n>node</span> <span class=o>*</span><span class=n>root</span><span class=p>;</span>

  <span class=c1>// Guardamos en T el resultado
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si un 치rbol es vac칤o, retornamos el otro
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T2</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>

    <span class=c1>// Si T1 tiene mayor prioridad, su ra칤z ser치
</span><span class=c1></span>    <span class=c1>// la ra칤z del 치rbol fusionado
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// En el otro caso, gana la ra칤z de T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Guardaremos en T1, T2 los resultados
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>split</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// El split del treap vac칤o son dos treaps vac칤os
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T2</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si la llave de T es &lt;= x, entonces la ra칤z
</span><span class=c1></span>    <span class=c1>// y todo el sub치rbol izquierdo van en T1
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>&lt;=</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, la ra칤z y el sub치rbol derecho van en T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T2</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Un treap vac칤o no tiene nada
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// Encontramos x
</span><span class=c1></span>
    <span class=c1>// Si es menor que la llave, debe estar en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

    <span class=c1>// Y si no, en el derecho
</span><span class=c1></span>    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Search modificado para incrementar el count de x
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>insert</span><span class=p>(</span><span class=n>node</span> <span class=o>*</span><span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Un treap vac칤o no tiene nada
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=o>++</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>;</span>
      <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// Encontramos x
</span><span class=c1></span>    <span class=p>}</span>

    <span class=c1>// Si es menor que la llave, debe estar en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

    <span class=c1>// Y si no, en el derecho
</span><span class=c1></span>    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Llamada recursiva para ingresar nodo n
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si T es vac칤o, la inserci칩n es el nodo n
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si n tiene mayor prioridad que T, debe
</span><span class=c1></span>    <span class=c1>// ser la nueva ra칤z 
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, insertamos en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=c1>// si es que tiene una llave menor a la de T
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
    <span class=c1>// ... y en el caso contrario, en el sub치rbol derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>

    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// El treap vac칤o no contiene a x
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// Si la llave de T es x, reducimos el count
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=o>--</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>;</span>
      <span class=c1>// Y si llega a 0, eliminamos el nodo
</span><span class=c1></span>      <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=n>merge</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// Si no, buscamos x en el sub치rbol izquierdo cuando
</span><span class=c1></span>    <span class=c1>// es menor que la llave de T
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>erase</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
    <span class=c1>// Y si no, intentamos en el sub치rbol derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>erase</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>

<span class=k>public</span><span class=o>:</span>
  <span class=n>treap</span><span class=p>()</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=p>}</span>
  <span class=n>treap</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=p>}</span>

  <span class=c1>// Fusiona O con T
</span><span class=c1></span>  <span class=c1>// Requisito: llaves(T) &lt; llaves(O)
</span><span class=c1></span>  <span class=n>treap</span> <span class=o>&amp;</span><span class=n>merge</span><span class=p>(</span><span class=n>treap</span> <span class=o>&amp;</span><span class=n>O</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>O</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Deja los valores &lt;= x en T, 
</span><span class=c1></span>  <span class=c1>// devuelve los valores &gt; x en otro treap
</span><span class=c1></span>  <span class=n>treap</span> <span class=nf>split</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>treap</span> <span class=n>ans</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>ans</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Busca x en el treap
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Inserta el valor x en el treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si x ya se encuentra en el 치rbol,
</span><span class=c1></span>    <span class=c1>// no agregar un nuevo nodo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// Si no, procedemos a ingresarlo
</span><span class=c1></span>    <span class=k>return</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=c1>// Elimina x del treap 
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>erase</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>};</span>

<span class=n>mt19937_64</span> <span class=n>treap</span><span class=o>::</span><span class=n>MT</span><span class=p>(</span><span class=n>chrono</span><span class=o>::</span><span class=n>system_clock</span><span class=o>::</span><span class=n>now</span><span class=p>().</span>
                    <span class=n>time_since_epoch</span><span class=p>().</span><span class=n>count</span><span class=p>());</span>
</code></pre></div></details><h2 id=extensiones>Extensiones<a href=#extensiones class=anchor aria-hidden=true>#</a></h2><p>Ok, hasta ahora hemos creado un 치rbol binario de busqueda con garant칤as fuertes sobre su altura y desempe침o $O(\log n)$. 쯈ue ventajas tiene sobre, digamos, un <strong>set</strong> de la librer칤a est치ndar? Se pueden resumir en unos puntos:</p><ol><li>Su implementaci칩n es relativamente simple, una vez que tenemos <strong>Merge</strong> y <strong>Split</strong> implementados podemos crear operaciones bastante m치s complejas a partir de ellos.</li><li>Dado que la implementaci칩n la estamos haciendo nosotros, podemos modificarla a nuestro gusto para agregar funcionalidad extra, a diferencia de <strong>set</strong> que no es tan f치cil de modificar.</li></ol><p>Por ejemplo, si agregamos un parametro <strong>size</strong> a los nodos del treap que guarden el tama침o de cada sub치rbol, podemos hacer consultas del tipo &ldquo;쮺ual es la $k$-칠sima llave en el treap?&rdquo; y &ldquo;쮺uantas llaves son $&lt;=$ al valor $x$?&rdquo;. Describiremos estos algoritmos, utilizando <strong>Size($T$)</strong> para referirnos al tama침o de $T$:</p><h3 id=cuantiles>Cuantiles<a href=#cuantiles class=anchor aria-hidden=true>#</a></h3><p>Hablaremos del $k$-칠simo cuantil como la $k$-칠sima llave guardada en el treap, considerando que la llave m치s peque침a es la $0$-칠sima. Como siempre, utilizamos un algoritmo recursivo:</p><h4 id=quantilet-k>Quantile($T, k$):<a href=#quantilet-k class=anchor aria-hidden=true>#</a></h4><ul><li>Si el tama침o del sub치rbol izquierdo <strong>Size($L$)</strong> es $k$, significa que la llave de $T$ es justamente el $k$-칠simo valor del treap y la devolvemos.</li><li>Si <strong>Size($L$)</strong> $ > k$, entonces la respuesta que buscamos se encuentra en el sub치rbol izquierdo y devolvemos <strong>Quantile($L, k$)</strong></li><li>En el caso contrario, debemos bajar al sub치rbol derecho a buscar la respuesta. Ojo que estamos salt치ndonos <strong>Size($L$)</strong> $ + 1$ llaves al hacer esto, correspondientes a las guardadas en el sub치rbol derecho m치s la ra칤z, por lo que debemos llamar a <strong>Quantile($R, k - (\textbf{Size}(L) + 1)$)</strong>.</li></ul><p>Claramente, este algoritmo solo tiene sentido cuando $k &lt;$ <strong>Size($T$)</strong>. Como en el peor caso descendemos por todo el 치rbol, esto tiene complejidad $O(\log n)$.</p><h3 id=rango>Rango<a href=#rango class=anchor aria-hidden=true>#</a></h3><p>Llamaremos al rango de un valor $x$ como la cantidad de llaves que son $\leq$ a $x$ en el treap. Podemos hacer esto mediante otro algoritmo recursivo:</p><h4 id=rankt-x>Rank($T, x$):<a href=#rankt-x class=anchor aria-hidden=true>#</a></h4><ul><li>Si $T$ es vac칤o, entonces <strong>Rank($T, x$)</strong> $= 0$.</li><li>Si $x$ es menor que la llave de $T$, entonces todos las llaves menores a $x$ se van a encontrar en el sub치rbol izquierdo de $T$, y devolvemos <strong>Rank($L, x$)</strong>.</li><li>Si no es el caso, tanto la ra칤z como el sub치rbol izquierdo de $T$ tienen llaves con valores $&lt;= x$,
y deben ser inclu칤dos en la respuesta. Respondemos <strong>Size($L$)</strong> + 1 + <strong>Rank($R, x$)</strong>.</li></ul><p>El algoritmo en el peor caso toma $O(\log n)$ por el argumento de profundidad.</p><details><summary>C칩digo</summary><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>

<span class=c1>// Clase wrapper
</span><span class=c1></span><span class=k>class</span> <span class=nc>treap</span> <span class=p>{</span>
<span class=k>private</span><span class=o>:</span>
  <span class=k>static</span> <span class=n>mt19937_64</span> <span class=n>MT</span><span class=p>;</span>

  <span class=k>static</span> <span class=n>ll</span> <span class=nf>random_number</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>MT</span><span class=p>();</span>
  <span class=p>}</span>

  <span class=k>struct</span> <span class=nc>node</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>left</span><span class=p>,</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>key</span><span class=p>,</span> <span class=n>priority</span><span class=p>;</span>
    <span class=c1>// Tama침o del sub치rbol
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span>

    <span class=n>node</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>left</span> <span class=o>=</span> <span class=n>right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=n>key</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
      <span class=n>priority</span> <span class=o>=</span> <span class=n>random_number</span><span class=p>();</span>
      <span class=n>sz</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>    
  <span class=p>};</span>

  <span class=c1>// Funci칩n utilitaria para obtener el size
</span><span class=c1></span>  <span class=kt>int</span> <span class=nf>sz</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>T</span> <span class=o>?</span> <span class=n>T</span><span class=o>-&gt;</span><span class=nl>sz</span> <span class=p>:</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>

  <span class=c1>// Mantiene las invariantes del treap
</span><span class=c1></span>  <span class=c1>// llamar cada vez que se altera la estructura del Treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>update</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>T</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>sz</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>sz</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=n>node</span> <span class=o>*</span><span class=n>root</span><span class=p>;</span>

  <span class=c1>// Guardamos en T el resultado
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si un 치rbol es vac칤o, retornamos el otro
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T2</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>

    <span class=c1>// Si T1 tiene mayor prioridad, su ra칤z ser치
</span><span class=c1></span>    <span class=c1>// la ra칤z del 치rbol fusionado
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// En el otro caso, gana la ra칤z de T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Guardaremos en T1, T2 los resultados
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>split</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// El split del treap vac칤o son dos treaps vac칤os
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T2</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si la llave de T es &lt;= x, entonces la ra칤z
</span><span class=c1></span>    <span class=c1>// y todo el sub치rbol izquierdo van en T1
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>&lt;=</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, la ra칤z y el sub치rbol derecho van en T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T2</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Un treap vac칤o no tiene nada
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// Encontramos x
</span><span class=c1></span>
    <span class=c1>// Si es menor que la llave, debe estar en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

    <span class=c1>// Y si no, en el derecho
</span><span class=c1></span>    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Llamada recursiva para ingresar nodo n
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si T es vac칤o, la inserci칩n es el nodo n
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si n tiene mayor prioridad que T, debe
</span><span class=c1></span>    <span class=c1>// ser la nueva ra칤z 
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, insertamos en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=c1>// si es que tiene una llave menor a la de T
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
    <span class=c1>// ... y en el caso contrario, en el sub치rbol derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// El treap vac칤o no contiene a x
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// Si la llave de T es x, debemos eliminar la ra칤z
</span><span class=c1></span>    <span class=c1>// y juntar sus sub치rboles
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// Si no, buscamos x en el sub치rbol izquierdo cuando
</span><span class=c1></span>    <span class=c1>// es menor que la llave de T
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>erase</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
    <span class=c1>// Y si no, intentamos en el sub치rbol derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>erase</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=n>ll</span> <span class=nf>quantile</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si el tama침o del sub치rbol izquierdo es k,
</span><span class=c1></span>    <span class=c1>// la respuesta es T-&gt;key
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>sz</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>==</span> <span class=n>k</span><span class=p>)</span> <span class=k>return</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>;</span>
    <span class=c1>// Si k &lt; el tama침o del sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>sz</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>))</span> <span class=k>return</span> <span class=n>quantile</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
    <span class=c1>// Y si no, en el derecho
</span><span class=c1></span>    <span class=k>return</span> <span class=n>quantile</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>k</span> <span class=o>-</span> <span class=p>(</span><span class=n>sz</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=kt>int</span> <span class=nf>rank</span><span class=p>(</span><span class=n>node</span> <span class=o>*</span><span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Un treap vac칤o no contiene nada
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=c1>// Si x &lt; T-&gt;key, todas las llaves menores 
</span><span class=c1></span>    <span class=c1>// se encuentran en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=k>return</span> <span class=n>rank</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
    <span class=c1>// Si no, inclu칤mos la ra칤z y todo el sub치rbol
</span><span class=c1></span>    <span class=c1>// izquierdo en la respuesta
</span><span class=c1></span>    <span class=k>return</span> <span class=p>(</span><span class=n>sz</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>rank</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

<span class=k>public</span><span class=o>:</span>
  <span class=n>treap</span><span class=p>()</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=p>}</span>
  <span class=n>treap</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=p>}</span>

  <span class=c1>// Fusiona O con T
</span><span class=c1></span>  <span class=c1>// Requisito: llaves(T) &lt; llaves(O)
</span><span class=c1></span>  <span class=n>treap</span> <span class=o>&amp;</span><span class=n>merge</span><span class=p>(</span><span class=n>treap</span> <span class=o>&amp;</span><span class=n>O</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>O</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Deja los valores &lt;= x en T, 
</span><span class=c1></span>  <span class=c1>// devuelve los valores &gt; x en otro treap
</span><span class=c1></span>  <span class=n>treap</span> <span class=nf>split</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>treap</span> <span class=n>ans</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>ans</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Busca x en el treap
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Inserta el valor x en el treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si x ya se encuentra en el 치rbol,
</span><span class=c1></span>    <span class=c1>// no agregar
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>search</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// Si no, procedemos a ingresarlo
</span><span class=c1></span>    <span class=k>return</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=c1>// Elimina x del treap 
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>erase</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=kt>int</span> <span class=nf>size</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>sz</span><span class=p>(</span><span class=n>root</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Encuentra el k-esimo valor del treap
</span><span class=c1></span>  <span class=n>ll</span> <span class=nf>quantile</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>quantile</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Calcula cuantos valores son &lt;= x en el Treap
</span><span class=c1></span>  <span class=kt>int</span> <span class=nf>rank</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>rank</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>};</span>

<span class=n>mt19937_64</span> <span class=n>treap</span><span class=o>::</span><span class=n>MT</span><span class=p>(</span><span class=n>chrono</span><span class=o>::</span><span class=n>system_clock</span><span class=o>::</span><span class=n>now</span><span class=p>().</span>
                    <span class=n>time_since_epoch</span><span class=p>().</span><span class=n>count</span><span class=p>());</span>
</code></pre></div></details><p>쯈ue otras cosas podemos hacer? Tambi칠n podemos guardar informaci칩n extra de los sub치rboles, como la suma de los valores, el producto, la suma de los valores al cuadrado etc etc, y consultar por estos valores por rango.</p><h2 id=-treaps-como-mapas--arreglos-> Treaps como mapas / arreglos ?<a href=#-treaps-como-mapas--arreglos- class=anchor aria-hidden=true>#</a></h2><p>Hasta ahora hemos visto los <strong>treaps</strong> como implementanciones de la estructura <strong>set</strong>, que puede buscar, insertar y borrar llaves en $O(\log n)$. Si a cada llave en el treap le asociamos un valor, obtenemos directamente la implementaci칩n de un <strong>map</strong>. En el caso de que las llaves sean enteros, podemos pensar en un <strong>map</strong> implementado como <strong>treap</strong> como una implementaci칩n un poco particular de un arreglo.</p><p>Lo interesante de este &ldquo;arreglo&rdquo; son algunas cosas:</p><ol><li>Si guardamos solamente las posiciones del arreglo que han cambiado desde alg칰n valor default, podemos trabajar con arreglos arbitrariamente grandes. Por ejemplo, podemos tener un arreglo de tama침o $10^{18}$, donde las posiciones inician en $0$, y guardamos en el <strong>treap</strong> solamente aquellos 칤ndices que se han modificado.</li><li>En cada nodo del treap podemos guardar metadatos sobre los sub치rboles, como por ejemplo la suma, el m칤nimo/m치ximo, el producto, etc. Y utilizando <strong>Merge</strong> y <strong>Split</strong>, podemos consultar esta informaci칩n por rango (춰Como un <strong>Segment Tree</strong>!)</li></ol><p>Aqu칤 una idea de como implementar esto:</p><details><summary>C칩digo</summary><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// Clase wrapper
</span><span class=c1></span><span class=k>class</span> <span class=nc>treap</span> <span class=p>{</span>
<span class=k>private</span><span class=o>:</span>
  <span class=k>static</span> <span class=n>mt19937_64</span> <span class=n>MT</span><span class=p>;</span>

  <span class=k>static</span> <span class=n>ll</span> <span class=nf>random_number</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>MT</span><span class=p>();</span>
  <span class=p>}</span>

  <span class=k>struct</span> <span class=nc>node</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>left</span><span class=p>,</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>key</span><span class=p>,</span> <span class=n>priority</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>value</span><span class=p>,</span> <span class=n>max_value</span><span class=p>;</span>

    <span class=n>node</span><span class=p>(</span><span class=n>ll</span> <span class=n>k</span><span class=p>,</span> <span class=n>ll</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>left</span> <span class=o>=</span> <span class=n>right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=n>key</span> <span class=o>=</span> <span class=n>k</span><span class=p>;</span>
      <span class=n>priority</span> <span class=o>=</span> <span class=n>random_number</span><span class=p>();</span>
      <span class=n>max_value</span> <span class=o>=</span> <span class=n>value</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
    <span class=p>}</span>    
  <span class=p>};</span>

  <span class=c1>// Funciones utilitarias
</span><span class=c1></span>  <span class=n>ll</span> <span class=nf>value</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>T</span> <span class=o>?</span> <span class=n>T</span><span class=o>-&gt;</span><span class=nl>value</span> <span class=p>:</span> <span class=o>-</span><span class=n>INF</span><span class=p>;</span> <span class=p>}</span>
  <span class=n>ll</span> <span class=nf>max_value</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>T</span> <span class=o>?</span> <span class=n>T</span><span class=o>-&gt;</span><span class=nl>max_value</span> <span class=p>:</span> <span class=o>-</span><span class=n>INF</span><span class=p>;</span> <span class=p>}</span>

  <span class=c1>// Mantiene las invariantes del treap
</span><span class=c1></span>  <span class=c1>// llamar cada vez que se altera la estructura del Treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>update</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>T</span><span class=o>-&gt;</span><span class=n>max_value</span> <span class=o>=</span> 
    <span class=n>max</span><span class=p>({</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>,</span> <span class=n>max_value</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>),</span> <span class=n>max_value</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>)});</span>
  <span class=p>}</span>

  <span class=n>node</span> <span class=o>*</span><span class=n>root</span><span class=p>;</span>

  <span class=c1>// Guardamos en T el resultado
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si un 치rbol es vac칤o, retornamos el otro
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T2</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>

    <span class=c1>// Si T1 tiene mayor prioridad, su ra칤z ser치
</span><span class=c1></span>    <span class=c1>// la ra칤z del 치rbol fusionado
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// En el otro caso, gana la ra칤z de T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Merge triple de utilidad
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T2</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T3</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>T</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Guardaremos en T1, T2 los resultados
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>split</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// El split del treap vac칤o son dos treaps vac칤os
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T2</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si la llave de T es &lt;= x, entonces la ra칤z
</span><span class=c1></span>    <span class=c1>// y todo el sub치rbol izquierdo van en T1
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>&lt;=</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, la ra칤z y el sub치rbol derecho van en T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T2</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Split triple T1 &lt; x, x &lt;= T2 &lt;= y, T3 &gt; y
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>split</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>,</span> <span class=n>ll</span> <span class=n>y</span><span class=p>,</span>
            <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T2</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T3</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Ahora T2 contiene los valores &gt;= x
</span><span class=c1></span>    <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>x</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span> 
    <span class=c1>// Y con esto T2 contiene los valores en [x, y]
</span><span class=c1></span>    <span class=n>split</span><span class=p>(</span><span class=n>T2</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Un treap vac칤o no tiene nada
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// Encontramos x
</span><span class=c1></span>
    <span class=c1>// Si es menor que la llave, debe estar en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

    <span class=c1>// Y si no, en el derecho
</span><span class=c1></span>    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Llamada recursiva para ingresar nodo n
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si T es vac칤o, la inserci칩n es el nodo n
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si n tiene mayor prioridad que T, debe
</span><span class=c1></span>    <span class=c1>// ser la nueva ra칤z 
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, insertamos en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=c1>// si es que tiene una llave menor a la de T
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
    <span class=c1>// ... y en el caso contrario, en el sub치rbol derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>insert</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// El treap vac칤o no contiene a x
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// Si la llave de T es x, debemos eliminar la ra칤z
</span><span class=c1></span>    <span class=c1>// y juntar sus sub치rboles
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// Si no, buscamos x en el sub치rbol izquierdo cuando
</span><span class=c1></span>    <span class=c1>// es menor que la llave de T
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>erase</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
    <span class=c1>// Y si no, intentamos en el sub치rbol derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>erase</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Guarda el valor v en el nodo con llave k
</span><span class=c1></span>  <span class=c1>// Retorna true si k estaba en el treap
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>set</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>k</span><span class=p>,</span> <span class=n>ll</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// Un treap vac칤o no tiene nada
</span><span class=c1></span>
    <span class=kt>bool</span> <span class=n>found</span><span class=p>;</span>
    <span class=c1>// Si la llave es k, la encontramos
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>=</span> <span class=n>k</span><span class=p>;</span>
      <span class=n>found</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// Encontramos k
</span><span class=c1></span>    <span class=p>}</span>
    <span class=c1>// Si es menor que la llave, debe estar en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=n>found</span> <span class=o>=</span> <span class=n>set</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span>
    <span class=c1>// Y si no, en el derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>found</span> <span class=o>=</span> <span class=n>set</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span>

    <span class=k>if</span><span class=p>(</span><span class=n>found</span><span class=p>)</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>found</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Encuentra el nodo con llave k,
</span><span class=c1></span>  <span class=c1>// NULL si no existe
</span><span class=c1></span>  <span class=n>node</span><span class=o>*</span> <span class=nf>find</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=n>ll</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si T es vac칤o, k no est치 en el 치rbol
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>

    <span class=c1>// Encontramos la respuesta
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>==</span> <span class=n>k</span><span class=p>)</span> <span class=k>return</span> <span class=n>T</span><span class=p>;</span>

    <span class=c1>// Si k &lt; T-&gt;key, buscamos en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>)</span> <span class=k>return</span> <span class=n>find</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
    <span class=c1>// Si no, en el derecho
</span><span class=c1></span>    <span class=k>return</span> <span class=n>find</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
  <span class=p>}</span>

<span class=k>public</span><span class=o>:</span>
  <span class=n>treap</span><span class=p>()</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=p>}</span>
  <span class=n>treap</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=p>}</span>

  <span class=c1>// Fusiona O con T
</span><span class=c1></span>  <span class=c1>// Requisito: llaves(T) &lt; llaves(O)
</span><span class=c1></span>  <span class=n>treap</span> <span class=o>&amp;</span><span class=n>merge</span><span class=p>(</span><span class=n>treap</span> <span class=o>&amp;</span><span class=n>O</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>O</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Deja los valores &lt;= x en T, 
</span><span class=c1></span>  <span class=c1>// devuelve los valores &gt; x en otro treap
</span><span class=c1></span>  <span class=n>treap</span> <span class=nf>split</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>treap</span> <span class=n>ans</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>ans</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Busca x en el treap
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Inserta el valor x en el treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si x ya se encuentra en el 치rbol,
</span><span class=c1></span>    <span class=c1>// no agregar
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>search</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// Si no, procedemos a ingresarlo
</span><span class=c1></span>    <span class=k>return</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=c1>// Elimina x del treap 
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>erase</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Guarda el valor v en la llave k
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>set</span><span class=p>(</span><span class=n>ll</span> <span class=n>k</span><span class=p>,</span> <span class=n>ll</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si k ya se encuentra en el 치rbol, no crear un nodo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>set</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span>

    <span class=c1>// Si no, procedemos a ingresarlo
</span><span class=c1></span>    <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>v</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=c1>// Devuelve el valor v guardado en la
</span><span class=c1></span>  <span class=c1>// llave k. Si no esta, lo crea con v = 0
</span><span class=c1></span>  <span class=n>ll</span> <span class=k>operator</span><span class=p>[](</span><span class=n>ll</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>node</span><span class=o>*</span> <span class=n>n</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
    <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>n</span> <span class=o>=</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>k</span><span class=p>);</span>
      <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Retorna el m치ximo valor guardado en el treap T
</span><span class=c1></span>  <span class=c1>// en el rango de llaves [a, b]
</span><span class=c1></span>  <span class=n>ll</span> <span class=nf>query</span><span class=p>(</span><span class=n>ll</span> <span class=n>a</span><span class=p>,</span> <span class=n>ll</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>T1</span><span class=p>,</span> <span class=o>*</span><span class=n>T2</span><span class=p>,</span> <span class=o>*</span><span class=n>T3</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>

    <span class=n>ll</span> <span class=n>ans</span> <span class=o>=</span> <span class=n>max_value</span><span class=p>(</span><span class=n>T2</span><span class=p>);</span>

    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>};</span>

<span class=n>mt19937_64</span> <span class=n>treap</span><span class=o>::</span><span class=n>MT</span><span class=p>(</span><span class=n>chrono</span><span class=o>::</span><span class=n>system_clock</span><span class=o>::</span><span class=n>now</span><span class=p>().</span>
                    <span class=n>time_since_epoch</span><span class=p>().</span><span class=n>count</span><span class=p>());</span>
</code></pre></div></details><h2 id=implicit-treap>Implicit Treap<a href=#implicit-treap class=anchor aria-hidden=true>#</a></h2><p>En el caso particular de que guardemos arreglos &ldquo;enteros&rdquo; (es decir, en un arreglo de tama침o $n$, guardamos todos los 칤ndices como llaves), podemos hacer algo a칰n mejor. Imaginemos queremos un arreglo donde vamos a:</p><ol><li>Agregar valores en posiciones arbitrarias</li><li>Eliminar valores en posiciones arbitrarias</li><li>Tomar rangos del arreglo y cambiarlos de posici칩n</li></ol><p>En un arreglo normal, todas estas operaciones tomar칤an tiempo $O(n)$ pues involucrar칤an cambiar $O(n)$ posiciones en el peor caso. En un treap normal, esto tambi칠n tomar칤a tiempo $O(n)$ pues, de nuevo, tendr칤amos que modificar $O(n)$ llaves para mantener el arreglo.</p><p>Pero&mldr; si no tuvieramos que guardar las llaves, no tendr칤amos por que preocuparnos de actualizarlas. En la implementaci칩n de <strong>Quantile</strong> vimos como acceder a la $k$-칠sima llave del <strong>treap</strong> <strong>sin usar en absoluto las llaves</strong>, usando solamente los <strong>tama침os</strong> como gu칤a.</p><p>Y, naturalmente, si en el <strong>treap</strong> guardamos un arreglo, la $k$-칠sima llave es la $k$-칠sima posici칩n de nuestro arreglo. Es decir, que si nos preocupamos de mantener la informaci칩n de los tama침os de forma correcta, podemos deshacernos de las llaves por completo. Y si ya no tenemos llaves, ya no tenemos que preocuparnos de mantenerlas actualizadas, y podemos implementar las operaciones antes mencionadas usando <strong>Split</strong> y <strong>Merge</strong>. No es trivial olvidarse de las llaves, y sin ellas podemos entender intuitivamente las operaciones <strong>Split</strong> y <strong>Merge</strong> como:</p><ol><li><strong>Split($T, k$)</strong> toma un arreglo guardado en un treap $T$ y lo separa en dos treaps, que guardan los primeros $k$ 칤ndices y los 칰ltimos $n-k$ 칤ndices.</li><li><strong>Merge($T_1, T_2$)</strong> concatena los arreglos guardados en $T_1$ y $T_2$.</li></ol><p>Adicionalmente, mediante estrategias de updates lazy, podemos hacer operaciones por rango como sumarle $x$ a todos los valores en $[i, j]$, y en el caso particular de treaps dar vuelta un rango. La idea es que al igual que debemos preocuparnos de mantener las invariantes en el treap como el tama침o, al momento de accesar el valor de un nodo o de intentar cambiar su estructura debemos preocuparnos de hacer el update lazy y empujarlo a los hijos.</p><p>Dejamos el detalle en el siguiente c칩digo:</p><details><summary>C칩digo</summary><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>

<span class=c1>// Clase wrapper
</span><span class=c1></span><span class=k>class</span> <span class=nc>implicit_treap</span> <span class=p>{</span>
<span class=k>private</span><span class=o>:</span>
  <span class=k>static</span> <span class=n>mt19937_64</span> <span class=n>MT</span><span class=p>;</span>

  <span class=k>static</span> <span class=n>ll</span> <span class=nf>random_number</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>MT</span><span class=p>();</span>
  <span class=p>}</span>

  <span class=k>struct</span> <span class=nc>node</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>left</span><span class=p>,</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>priority</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>value</span><span class=p>,</span> <span class=n>sum_value</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>lazy_sum</span><span class=p>;</span>
    <span class=kt>bool</span> <span class=n>lazy_flip</span><span class=p>;</span>

    <span class=n>node</span><span class=p>(</span><span class=n>ll</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>left</span> <span class=o>=</span> <span class=n>right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=n>priority</span> <span class=o>=</span> <span class=n>random_number</span><span class=p>();</span>
      <span class=n>sz</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
      <span class=n>sum_value</span> <span class=o>=</span> <span class=n>value</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
      <span class=n>lazy_sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
      <span class=n>lazy_flip</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
    <span class=p>}</span>    
  <span class=p>};</span>

  <span class=c1>// Funciones utilitarias
</span><span class=c1></span>  <span class=n>ll</span> <span class=nf>value</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>T</span> <span class=o>?</span> <span class=n>T</span><span class=o>-&gt;</span><span class=nl>value</span> <span class=p>:</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
  <span class=n>ll</span> <span class=nf>sum_value</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>T</span> <span class=o>?</span> <span class=n>T</span><span class=o>-&gt;</span><span class=nl>sum_value</span> <span class=p>:</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
  <span class=kt>int</span> <span class=nf>sz</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>T</span> <span class=o>?</span> <span class=n>T</span><span class=o>-&gt;</span><span class=nl>sz</span> <span class=p>:</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
  <span class=kt>int</span> <span class=nf>key</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>sz</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span> <span class=p>}</span>

  <span class=c1>// Mantiene las invariantes del treap
</span><span class=c1></span>  <span class=c1>// llamar cada vez que se altera la estructura del Treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>update</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>T</span><span class=o>-&gt;</span><span class=n>sum_value</span> <span class=o>=</span> 
      <span class=n>T</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>+</span> <span class=n>sum_value</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>sum_value</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
    <span class=n>T</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>sz</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>sz</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=kt>void</span> <span class=nf>sum_push</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>lazy_sum</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>+=</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>lazy_sum</span><span class=p>;</span>
      <span class=n>T</span><span class=o>-&gt;</span><span class=n>sum_value</span> <span class=o>+=</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>sz</span><span class=o>*</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>lazy_sum</span><span class=p>;</span>

      <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>-&gt;</span><span class=n>lazy_sum</span> <span class=o>+=</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>lazy_sum</span><span class=p>;</span>
      <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>)</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>-&gt;</span><span class=n>lazy_sum</span> <span class=o>+=</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>lazy_sum</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>T</span><span class=o>-&gt;</span><span class=n>lazy_sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=kt>void</span> <span class=nf>flip_push</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>lazy_flip</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>swap</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>

      <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>-&gt;</span><span class=n>lazy_flip</span> <span class=o>=</span> <span class=o>!</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>-&gt;</span><span class=n>lazy_flip</span><span class=p>;</span>
      <span class=k>if</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>)</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>-&gt;</span><span class=n>lazy_flip</span> <span class=o>=</span> <span class=o>!</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>-&gt;</span><span class=n>lazy_flip</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>T</span><span class=o>-&gt;</span><span class=n>lazy_flip</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=kt>void</span> <span class=nf>push</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>sum_push</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
    <span class=n>flip_push</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=n>node</span> <span class=o>*</span><span class=n>root</span><span class=p>;</span>

  <span class=c1>// Guardamos en T el resultado
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Si un 치rbol es vac칤o, retornamos el otro
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T2</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>

    <span class=c1>// Hacer el update a ultimo minuto
</span><span class=c1></span>    <span class=n>push</span><span class=p>(</span><span class=n>T1</span><span class=p>);</span> <span class=n>push</span><span class=p>(</span><span class=n>T2</span><span class=p>);</span>

    <span class=c1>// Si T1 tiene mayor prioridad, su ra칤z ser치
</span><span class=c1></span>    <span class=c1>// la ra칤z del 치rbol fusionado
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// En el otro caso, gana la ra칤z de T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>merge</span><span class=p>(</span><span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T</span> <span class=o>=</span> <span class=n>T2</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Merge triple de utilidad
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T2</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=n>T3</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>T</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Guardaremos en T1, T2 los resultados
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>split</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T2</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// El split del treap vac칤o son dos treaps vac칤os
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T2</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Update a ultimo minuto
</span><span class=c1></span>    <span class=n>push</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>

    <span class=c1>// Si key(T) &lt; k, entonces la ra칤z
</span><span class=c1></span>    <span class=c1>// y todo el sub치rbol izquierdo van en T1
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>key</span><span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>k</span> <span class=o>-</span> <span class=p>(</span><span class=n>key</span><span class=p>(</span><span class=n>T</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span>
      <span class=n>T1</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Si no, la ra칤z y el sub치rbol derecho van en T2
</span><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
      <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
      <span class=n>T2</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Split triple T1 &lt; i, i &lt;= T2 &lt;= j, T3 &gt; j
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>split</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>,</span>
            <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T1</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T2</span><span class=p>,</span> <span class=n>node</span><span class=o>*</span> <span class=o>&amp;</span><span class=n>T3</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Ahora T2 contiene los valores &gt;= x
</span><span class=c1></span>    <span class=n>split</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>);</span> 
    <span class=c1>// Y con esto T2 contiene los valores en [x, y]
</span><span class=c1></span>    <span class=n>split</span><span class=p>(</span><span class=n>T2</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=n>i</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Guarda el valor v en la posicion k
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>set</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=n>ll</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>push</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>

    <span class=k>if</span><span class=p>(</span><span class=n>key</span><span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=o>==</span> <span class=n>k</span><span class=p>)</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
    <span class=c1>// Si es menor que la llave, debe estar en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>key</span><span class=p>(</span><span class=n>T</span><span class=p>))</span> <span class=n>set</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span>
    <span class=c1>// Y si no, en el derecho
</span><span class=c1></span>    <span class=k>else</span> <span class=n>set</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>k</span> <span class=o>-</span> <span class=p>(</span><span class=n>key</span><span class=p>(</span><span class=n>T</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span> <span class=n>v</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>update</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Encuentra el nodo que guarda la posici칩n k
</span><span class=c1></span>  <span class=n>node</span><span class=o>*</span> <span class=nf>find</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>push</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>

    <span class=c1>// Encontramos la respuesta
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>key</span><span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=o>==</span> <span class=n>k</span><span class=p>)</span> <span class=k>return</span> <span class=n>T</span><span class=p>;</span>

    <span class=c1>// Si k &lt; T-&gt;key, buscamos en el sub치rbol izquierdo
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>key</span><span class=p>(</span><span class=n>T</span><span class=p>))</span> <span class=k>return</span> <span class=n>find</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
    <span class=c1>// Si no, en el derecho
</span><span class=c1></span>    <span class=k>return</span> <span class=n>find</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>k</span> <span class=o>-</span> <span class=p>(</span><span class=n>key</span><span class=p>(</span><span class=n>T</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=c1>// Funci칩n auxiliar para imprimir el treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>

    <span class=n>push</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>

    <span class=n>print</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>T</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
    <span class=n>print</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
  <span class=p>}</span>

<span class=k>public</span><span class=o>:</span>
  <span class=n>implicit_treap</span><span class=p>()</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=p>}</span>
  <span class=n>implicit_treap</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=p>}</span>

  <span class=kt>int</span> <span class=nf>size</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>sz</span><span class=p>(</span><span class=n>root</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Concatena T con O
</span><span class=c1></span>  <span class=n>implicit_treap</span> <span class=o>&amp;</span><span class=n>merge</span><span class=p>(</span><span class=n>implicit_treap</span> <span class=o>&amp;</span><span class=n>O</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>O</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Deja los valores &lt;= x en T, 
</span><span class=c1></span>  <span class=c1>// devuelve los valores &gt; x en otro treap
</span><span class=c1></span>  <span class=n>implicit_treap</span> <span class=nf>split</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>implicit_treap</span> <span class=n>ans</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>ans</span><span class=p>.</span><span class=n>root</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Elimina el rango [i, j] del treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>T1</span><span class=p>,</span> <span class=o>*</span><span class=n>T2</span><span class=p>,</span> <span class=o>*</span><span class=n>T3</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Elimina la posici칩n k del treap
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>erase</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Guarda el valor v en la posici칩n k
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>set</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=n>ll</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>set</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Devuelve el valor v guardado en la posici칩n k
</span><span class=c1></span>  <span class=n>ll</span> <span class=k>operator</span><span class=p>[](</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nf>find</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Retorna la suma de los valores guardado en T
</span><span class=c1></span>  <span class=c1>// en el rango de indices [i, j]
</span><span class=c1></span>  <span class=n>ll</span> <span class=nf>query</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>T1</span><span class=p>,</span> <span class=o>*</span><span class=n>T2</span><span class=p>,</span> <span class=o>*</span><span class=n>T3</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>

    <span class=n>ll</span> <span class=n>ans</span> <span class=o>=</span> <span class=n>sum_value</span><span class=p>(</span><span class=n>T2</span><span class=p>);</span>

    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Le suma x a todo el rango [i, j]
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>update</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>T1</span><span class=p>,</span> <span class=o>*</span><span class=n>T2</span><span class=p>,</span> <span class=o>*</span><span class=n>T3</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>

    <span class=n>T2</span><span class=o>-&gt;</span><span class=n>lazy_sum</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>

    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Da vuelta el rango [i, j]
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>flip</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>T1</span><span class=p>,</span> <span class=o>*</span><span class=n>T2</span><span class=p>,</span> <span class=o>*</span><span class=n>T3</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>

    <span class=n>T2</span><span class=o>-&gt;</span><span class=n>lazy_flip</span> <span class=o>=</span> <span class=o>!</span><span class=n>T2</span><span class=o>-&gt;</span><span class=n>lazy_flip</span><span class=p>;</span>

    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Inserta x en T de tal forma que T[i] = x
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>node</span><span class=o>*</span> <span class=n>T</span><span class=p>;</span>
    <span class=n>split</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>T</span><span class=p>);</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=n>T</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Agrega x al final de T
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>push_back</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=c1>// Agrega x al principio de T
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>push_front</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>merge</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=k>new</span> <span class=n>node</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=n>root</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Imprime todos los valores del treap en orden
</span><span class=c1></span>  <span class=c1>// i.e. [1, 2, 3] =&gt; 1 2 3 \\n
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>print</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>print</span><span class=p>(</span><span class=n>root</span><span class=p>);</span> 
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>};</span>

<span class=n>mt19937_64</span> <span class=n>implicit_treap</span><span class=o>::</span><span class=n>MT</span><span class=p>(</span><span class=n>chrono</span><span class=o>::</span><span class=n>system_clock</span><span class=o>::</span><span class=n>now</span><span class=p>().</span>
                    <span class=n>time_since_epoch</span><span class=p>().</span><span class=n>count</span><span class=p>());</span>
</code></pre></div></details><p class=edit-page><a href=https://github.com/progcompuch/apunte/blob/main/content/docs/extras/treaps.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Editar en GitHub</a>
<span class=date-info><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Modificado por 칰ltima vez el 09/12/2022 a las 00:56:41 hrs.</span></p><div class="docs-navigation d-flex justify-content-between"><a href=/docs/extras/recurrencias_lineales/><div class="card my-1"><div class="card-body py-2">&larr; Recurrencias Lineales</div></div></a><a class=ml-auto href=/docs/prologo/intro/><div class="card my-1"><div class="card-body py-2">Pr칩logo &rarr;</div></div></a></div></main></div></div></main><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Sitio generado con <a href=https://gohugo.io/>Hugo</a> y <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-right"><ul class=list-inline><a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></ul></div></div></div></footer><script src=/main.95e1e463215c36b92eed561d2047bd705784633ba53d9459f103fad71ac9237a03e92e1413824339f4dcfe6e260239c0e4237a48be33d73a1e686e025142d2ba.js integrity="sha512-leHkYyFcNrku7VYdIEe9cFeEYzulPZRZ8QP61xrJI3oD6S4UE4JDOfTc/m4mAjnA5CN6SL4z1zoeaG4CUULSug==" crossorigin=anonymous defer></script><script src=/index.min.4842d09dc7f066902873731a5a97076ea606633dcee608e067d3644daea6d31fe09e9d74caf1262f242d3e0427513335d7d4e4f15d57ba2a4cda20644c2bcb7d.js integrity="sha512-SELQncfwZpAoc3MaWpcHbqYGYz3O5gjgZ9NkTa6m0x/gnp10yvEmLyQtPgQnUTM119Tk8V1XuipM2iBkTCvLfQ==" crossorigin=anonymous defer></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>